///////////////////////////////////////////////////////////////////////////////
// AWDogController
// Copyright 2004 RWS, Inc.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////
class AWDogController extends DogController;

///////////////////////////////////////////////////////////////////////////////
// vars
///////////////////////////////////////////////////////////////////////////////
var class<Pickup> CaughtProjectilePickupClass;		// class of pickups made by the projectile we caught


///////////////////////////////////////////////////////////////////////////////
// consts
///////////////////////////////////////////////////////////////////////////////
const HERO_WAIT_STARTUP	=	0.5;
const HYPER_AWARE_TIME	=	0.6;


///////////////////////////////////////////////////////////////////////////
// When attacked
///////////////////////////////////////////////////////////////////////////
function damageAttitudeTo(pawn Other, float Damage)
{
	// If a cat attacks us, freak out no matter what
	if(AWCatPawn(Other) != None)
	{
		GotoState('RunAway');
	}
	// If a dog friendly person hurt me, don't mind them if I'm fighting and they didn't mean it, otherwise, run away
	else if(AWPerson(Other) != None
		&& AWPerson(Other).bDogFriend
		&& PersonController(Other.Controller) != None
		&& PersonController(Other.Controller).Attacker != Pawn)
	{
		if(Attacker == None)
		{
			// Play a got hurt noise, no matter what
			MyPawn.PlayHurtSound();
			GotoStateSave('RunAway');
		}
	}
	else
		Super.damageAttitudeTo(Other, Damage);
}

///////////////////////////////////////////////////////////////////////////////
// Copy over visuals and info on the projectile we caught in our mouth
///////////////////////////////////////////////////////////////////////////////
function SetupCatchProjectile(Projectile catchme)
{
	local int i;
	local rotator rel;

	MyBone = spawn(class'AnimNotifyActor',MyPawn);
	if(MyBone != None)
	{
		// Copy over visuals
		if(catchme.Mesh != None)
		{
			MyBone.SetDrawType(DT_Mesh);
			MyBone.LinkMesh(catchme.Mesh);
			if(catchme.Skins.Length > 0)
			{
				MyBone.Skins.Insert(0, catchme.Skins.Length);
				for(i=0; i<catchme.Skins.Length; i++)
				{
					MyBone.Skins[i] = catchme.Skins[i];
				}
			}
		}
		else
		{
			MyBone.SetStaticMesh(catchme.StaticMesh);
			if(catchme.Skins.Length > 0)
			{
				MyBone.Skins.Insert(0, catchme.Skins.Length);
				for(i=0; i<catchme.Skins.Length; i++)
				{
					MyBone.Skins[i] = catchme.Skins[i];
				}
			}
		}
		// stick it in his mouth
		MyPawn.AttachToBone(MyBone, MouthBone);
		rel.Roll=16000;
		rel.Yaw=16000;
		MyBone.SetRelativeRotation(rel);
	}
}

///////////////////////////////////////////////////////////////////////////////
// Check to see if we caught this projectile in our mouthes, that was thrown
// at us.
///////////////////////////////////////////////////////////////////////////////
function CheckCatchProjectile(Projectile catchme, class<Pickup> makeme, optional out byte StateChange)
{
	local vector usepos;

	if(catchme != None)
	{
		//  Just keep jumping in the direction of the projectile
		usepos = catchme.Location - MyPawn.Location;
		usepos.z = 0;
		usepos = POUNCE_DIST*Normal(usepos) + MyPawn.Location;
		SetEndPoint(usepos, DEFAULT_END_RADIUS);
		if(IsInState('LegMotionToTarget'))
			bPreserveMotionValues=true;
		SetNextState('DropProjectile');
		GotoStateSave('CatchProjectile');
		// Save what we'll end up dropping
		CaughtProjectilePickupClass = makeme;
		// Put the projectile in his mouth
		SetupCatchProjectile(catchme);
		StateChange=1;
	}
}

///////////////////////////////////////////////////////////////////////////////
//	No matter what, make sure to get rid of the bone in your mouth and
// redrop the pickup
///////////////////////////////////////////////////////////////////////////////
function DropCaughtProjectile()
{
	local vector useloc;
	local rotator userot;
	local Pickup DroppedBone;
	local vector newvel;
	local coords usecoords;

	if(MyBone != None)
	{
		useloc = MyBone.Location;
		userot = MyBone.Rotation;
		MyBone.Destroy();
		MyBone = None;
	}
	else
	{
		usecoords = Pawn.GetBoneCoords(MouthBone);
		useloc = usecoords.origin;
	}

	// Make the pickup to drop
	if(CaughtProjectilePickupClass != None)
		DroppedBone = spawn(CaughtProjectilePickupClass, , , useloc, userot);

	CaughtProjectilePickupClass = None;

	if(DroppedBone != None)
	{
		newvel.z = -200;
		DroppedBone.SetPhysics(PHYS_Falling);
		DroppedBone.Velocity = newvel;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Possess the pawn
///////////////////////////////////////////////////////////////////////////////
function Possess(Pawn aPawn)
{
	Super.Possess(aPawn);
	//log(Self$" hero tag "$MyPawn.HeroTag$" my hero "$Hero);
	// If the level just started up, and you didn't hook your hero correctly (not
	// after a transition from an old level where he was your hero--this is only
	// for being placed in a level with HeroTag set by the LD) then wait
	// for a minute in a different state for your dude to come in.
	if(MyPawn.HeroTag != ''
		&& Hero == None)
		GotoState('HeroWaitStartup');
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// You're waiting for your dude to come into the level. This only happens
// at the start of a level. You've got a hero pawn that you'd like,
// and the level started and you checked but there is no dude yet. So wait
// for a split second and try again.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state HeroWaitStartup extends Thinking
{
	ignores InterestIsAnnoyingUs, GetHitByDeadThing, BodyJuiceSquirtedOnMe, GettingDousedInGas, RespondToTalker, ForceGetDown, 
		MarkerIsHere, damageAttitudeTo, CatchOnFire, CheckForObstacles, Touch,
		StartledBySomething, RespondToAnimalCaller, InvestigatePrey, ReadyForASniff, Trigger;
Begin:
	Sleep(HERO_WAIT_STARTUP);

	HookHero(FPSPawn(FindActorByTag(MyPawn.HeroTag)));
	if(Hero != None)
		ChangeHeroLove(HERO_LOVE_MAX, 0);

	GotoState('Thinking');
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Falling through the air 
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state FallingFar
{
	///////////////////////////////////////////////////////////////////////////////
	// I've fallen to the ground
	///////////////////////////////////////////////////////////////////////////////
	function Landed(vector HitNormal)
	{
		//log(self$" hit ground");
		MyPawn.SetAnimWalking();

		GotoStateSave('RunAway');
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// DisperseAroundHero
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state DisperseAroundHero
{
	///////////////////////////////////////////////////////////////////////////////
	// Prep for the actual walking
	///////////////////////////////////////////////////////////////////////////////
	function SetupWalking()
	{
		SetNextState('Thinking');
		GotoStateSave('WalkToTargetWatchHero');
	}
Begin:
	PrintThisState();
	PickHeroSpot();
	SetupWalking();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// WalkToTargetWatchHero
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state WalkToTargetWatchHero extends WalkToTarget
{
	///////////////////////////////////////////////////////////////////////////////
	// Check to chase after your hero more often here
	///////////////////////////////////////////////////////////////////////////////
	function InterimChecks()
	{
		local float dist;
		local byte StateChange;

		// Check if the hero is too far away, if so cut after him
		dist = VSize(Hero.Location - MyPawn.Location);

		if(dist > HANG_AROUND_HERO)
		{
			GotoHero(, StateChange);
		}

		if(StateChange == 0)
			Super.InterimChecks();
	}
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function EndState()
	{
		FPSPawn(Pawn).PathCheckTimeActor = FPSPawn(Pawn).default.PathCheckTimeActor;
		FPSPawn(Pawn).PathCheckTimePoint = FPSPawn(Pawn).default.PathCheckTimePoint;
		Super.EndState();
	}
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function BeginState()
	{
		Super.BeginState();
		// Do more internal checks when moving like this
		FPSPawn(Pawn).PathCheckTimeActor = HYPER_AWARE_TIME;
		FPSPawn(Pawn).PathCheckTimePoint = HYPER_AWARE_TIME;
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Jump on this guy and hurt him
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state PounceOnTarget
{
	///////////////////////////////////////////////////////////////////////////////
	// stop at the animation end, and go about as before
	///////////////////////////////////////////////////////////////////////////////
	function AnimEnd(int channel)
	{
		MyPawn.AnimEnd(channel);
		// Check for the base channel only
		if(channel == 0)
		{
			// If we caught something in the mean time, drop the pickup
			if(MyBone != None)
				GotoStateSave('DropProjectile');
			else
				GotoStateSave('AttackTarget');
		}
	}

	///////////////////////////////////////////////////////////////////////////////
	// Check to see if we caught this projectile in our mouthes, that was thrown
	// at us.
	// Since we're already jumping through the air with our mouthes open, just
	// finish up this state and then drop the projectile.
	///////////////////////////////////////////////////////////////////////////////
	function CheckCatchProjectile(Projectile catchme, class<Pickup> makeme, optional out byte StateChange)
	{
		local vector usepos;

		if(catchme != None)
		{
			// Save what we'll end up dropping
			CaughtProjectilePickupClass = makeme;
			// Put the projectile in his mouth
			SetupCatchProjectile(catchme);
			StateChange=1;
		}
	}
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function EndState()
	{
		Super.EndState();

		// Drop our projectile if we're dying
		if(Pawn.Health <= 0)
			DropCaughtProjectile();
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Wrestling the thing back and forth, hurting it
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state ShredAttack
{
	ignores CheckCatchProjectile;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Wrestling the thing back and forth, hurting it
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state ShredDead
{
	ignores CheckCatchProjectile;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Jump and catch the projectile in mid air
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state CatchProjectile extends RunToAttacker
{
	ignores NextStateAfterGoal, CantFindPath, Touch, MarkerIsHere;
	///////////////////////////////////////////////////////////////////////////////
	// stop at the animation end, and go about as before
	///////////////////////////////////////////////////////////////////////////////
	function AnimEnd(int channel)
	{
		MyPawn.AnimEnd(channel);
		// Check for the base channel only
		if(channel == 0)
		{
			GotoStateSave('DropProjectile');
		}
	}

	///////////////////////////////////////////////////////////////////////////////
	// Play pounce anim
	///////////////////////////////////////////////////////////////////////////////
	function BeginState()
	{
		Super.BeginState();
		// He pounces in this anim
		DogPawn(MyPawn).PlayCatchProjectile();
		bHurtTarget=false;
	}
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function EndState()
	{
		Super.EndState();

		// If we're dead, drop the projectile now
		if(Pawn.Health <= 0)
			DropCaughtProjectile();

		bHurtTarget=false;
		MyPawn.ChangeAnimation();
		// Take him back to normal speed
		MyPawn.GroundSpeed = MyPawn.default.GroundSpeed;
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// DropProjectile
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state DropProjectile extends Barking
{
	ignores MarkerIsHere;

	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function FinishUp()
	{
		if(Attacker != None)
			GotoStateSave('AttackTarget');
		else
			GotoStateSave('Thinking');
	}

	///////////////////////////////////////////////////////////////////////////////
	//	No matter what, make sure to get rid of the bone in your mouth and
	// redrop the pickup
	///////////////////////////////////////////////////////////////////////////////
	function EndState()
	{

		Super.EndState();

		DropCaughtProjectile();
	}

Begin:
	MyPawn.PlayAnimStanding();
	Sleep(Frand());
	FinishUp();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

defaultproperties
{
}
