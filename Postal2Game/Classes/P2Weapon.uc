///////////////////////////////////////////////////////////////////////////////
// P2Weapon
// Copyright 2001 Running With Scissors, Inc.  All Rights Reserved.
//
// Our layer between their weapon class and all our weapons.
//
// This is the Inventory version of the weapon that is actually shot by the
// player. Generated by P2WeaponPickup.uc.
//
// History:
// 4/30 Kamek - code for shovel achievement
//
//	07/30/02 MJR	Added this line to history so it wouldn't be empty.
//					Also added an overview in the hopes that it will be easier
//					to understand this crap in the future.
//
///////////////////////////////////////////////////////////////////////////////
//
// Epic's weapon code fairly convoluted and completely undocumented, so here's
// an overview of how it works.
//
// Note that this overview only covers the firing sequence and ignores all
// the other stuff like idling, reloading, switching weapons, and so on.
//
// A players firing sequence starts when the player presses a button or key
// that is mapped to "Fire" via User.ini.  The event is handled by an exec
// function of the same name in PlayerController:
//
//		exec function Fire()
//			Unpause game if it was paused
//			Pawn.Weapon.Fire().
//
// An NPC's firing sequence starts when its controller calls Weapon.BotFire(),
// which in turn calls Weapon.Fire(), so it's similar to the player situation.
//
// Things happen slighty differently on a server versus a network client.
// Essentially, the server does most of what the client does and also checks
// for collisions and starts projectiles.  This slight differentiation leads
// to two sets of similar functions and states, one set for the server and
// another for the client.
//
// Let's start with Fire(), which starts off the whole sequence:
//
//		simulated Fire()
//			If no ammo then do nothing
//			ServerFire() or ServerRapidFire() which calls ServerFire()
//			If not ROLE_Authority
//				LocalFire()
//				GotoState 'ClientFiring'
//
// These functions/states are only used by a server (dedicated server or
// standalone game):
//
//		ServerFire()
//			If no ammo then do nothing
//			GotoState 'NormalFire'
//			TraceFire() or ProjectileFire() depending on ammo type
//			LocalFire()
//
//		state NormalFire
//			Waits for anim to end then calls Finish()
//
//		Finish()
//			In various situations GotoState 'Reloading' or 'DownWeapon' or 'Idle'
//			If controller is still pressing fire
//				Global.ServerFire()
//
//  These functions are shared by servers and clients:
//
//		simulated LocalFire()
//			If instigator is a locally controlled PlayerController then
//				PlayerController.ClientInstantFlash()
//				PlayerController.ShakeView()
//			If there is an Affector (powerup) on this weapon then
//				Affector.FireEffect()
//			PlayFiring()
//
//		simulated PlayFiring()
//			Play animations and sounds and whatever else
//
// These functions/states are only used by a network client:
//
//		state ClientFiring
//			Waits for anim to end then calls ClientFinish()
//
//		simulated ClientFinish()
//			In various situations GotoState '', 'Reloading', 'DownWeapon', or 'Idle'
//			If Instigator.PressingFire()
//				Global.Fire()
//			If Instigator.PressingAltFire()
//				Global.AltFire()
//
//
// AltFire is barely implemented by the Weapon class, leaving it up to an
// extended class (like this one) to implement any actual functionality.
// The Weapon class basically consists of these hooks:
//
//		simulated AltFire()
//			If not IsInState 'Idle'
//				GotoState 'Idle'
//			ServerAltFire()
//
//		ServerAltFire()
//			If not IsInState 'Idle'
//				GotoState 'Idle'
//
// Plus, there's code here and there that checks if AltFire is being pressed
// (or was pressed during the firing sequence) and if so, it calls AltFire()
// or ServerAltFire() when the current firing sequence ends.
//
// The current AltFire implementation in P2Weapon is is half-baked.  While
// many of the fire-related functions are duplicated for AltFire, there are
// a few functions shared by both modes.  And currently ALL of the states
// are shared by both modes.  This almost certainly has client/server
// problems, but we'll tackle that issue when the time comes.
//
///////////////////////////////////////////////////////////////////////////////
class P2Weapon extends Weapon
	abstract;


///////////////////////////////////////////////////////////////////////////////
// VARS
///////////////////////////////////////////////////////////////////////////////

var bool		bUsesAltFire;				// This weapon has an alt fire
var byte		ViolenceRank;				// Larger number, more violent the weapon is
var bool		bArrestableWeapon;			// When the cops see this weapon, they don't mind arresting you
											// like that (like you're hands or matches)
var bool		bJustMade;					// Someone just made me, so tell AmmoGetCount that you have ammo
											// even if it looks like you don't.
var float		RecognitionDist;			// Closest distance before you can make out a certain weapon
											// A bystander sees you aiming at them within this distance,
											// they'll run from you. A grenade will only cause this at a close
											// distance, but a pistol will cause bystanders
											// to run from you from a larger distance
var sound		HolsterSound,ReloadSound;

var int			ShotCount;					// How many shots fired
var int			ShotCountMaxForNotify;		// Frequency for notifying people of the danger (when you shot)
											// =3, every third shot they get notified, =1, every shot

var int			AI_BurstCountExtra;			// for the AI, extra number of times passed the minimum to fire in a burst
var int			AI_BurstCountMin;			// for the AI, min number of times to fire a weapon
var float		AI_BurstTime;				// for the AI, time in between which the AI waits before firing again

var class<TimedMarker> ShotMarkerMade;		// danger made when gun goes off
var class<TimedMarker> BulletHitMarkerMade;	// danger made when bullet hits
var class<TimedMarker> PawnHitMarkerMade;	// danger made when a pawn is hit by this weapon
											// The collision for this must be smaller than ShotMarkerMade

var vector		LastHitLocation;			// Where the last trace fire shot hit

var EWeaponHoldStyle	holdstyle;			// How to hold this weapon
var EWeaponHoldStyle	switchstyle;		// How to holster/bring up this weapon
var EWeaponHoldStyle	firingstyle;		// How to shoot this weapon

var float		UseWaitTime;				// Passed around to certain states during which they wait

var bool		bMakeInfiniteForNPCs;		// Whether this weapon is infinite ammo for NPC's.
											// Defaults to true, because most of the time, you want enemies
											// to constantly shoot at you and not run out.
var bool		bThrownByFiring;			// When you fire this weapon, you don't fire it,
											// you really toss it/throw it, like a grenade (if true)

var name		NoAmmoChangeState;			// When the weapon is out of ammo, he will call this state.
											// Defaults to DownWeapon, so a pistol will just be put away,
											// but thrown/projectile weapons sometimes need to have an
											// 'empty put away'.

var bool		bNoHudReticle;				// This doesn't want a reticle (like a melee weapon perhaps)
var Texture		ReticleTexture;				// Reticle texture
var Color		ReticleDefaultColor;		// Default reticle color
var Color		ReticleColor;				// Current reticle color (can be modified by each weapon)
var float 		ReticleSize;				// xPatch: gets reticle scale from P2Player

var	float		MinRange;					// Minimum range of weapon--don't be any closer than this when
											// when attacking with this weapon (opposite to Weapon::MaxRange)

var float		ShakeRollRate;				// Use to shake the camera per shot
var float		ShakeOffsetTime;

var class<P2WeaponPickupErrand>	ErrandPickupClass;	// Class of pickup type that we use for errand completion.
											// *Only* fill this in with the unique pickup class for this weapon that
											// will be used for an errand completion, if this weapon has a
											// pickup used to complete an errand. Defaults to None

//var int			InventoryRank;				// Absolute rank of weapons in the characters inventory. If a group
											// contains two weapons, the first is 1000, the next is 1001. If a group
											// exists after the first group, the first weapon there is 2000. This is
											// simply created from the InventoryGroup*INV_GROUP_FACTOR + GroupOffset.
											// This is to allow a complete cycling through of the weapons
											// rather than simply cycling through the groups.
var bool		bAltFiring;					// Currently executing an alt fire

var float		PlayerMeleeDist;			// Player distance in melee attacks
var float		NPCMeleeDist;				// distance within which NPCs hurt things with this melee weapon
var float		UseMeleeDist;				// Distance (picked from two above) that we use in practice

var byte		FlashMax;					// Number of frames to display a flash

var bool		bAllowDynamicLights;		// If this weapon is allowed to use dyanmic lights.. saved from the
											// game info on start up

var bool		bAllowHints;				// We're still at a point with the weapon where the player
											// needs hints -- permanent
var bool		bShowHints;					// Temporary, can be switched be back and forth
var localized string HudHint1;				// Generic hint to be displayed on HUD for this weapon
var localized string HudHint2;
var localized string HudHint3;
var localized string DropWeaponHint1;		// Police want you to drop your weapon
var localized string DropWeaponHint2;
var const localized string StandStillHint;	// Stand still while they cuff you
var const localized string TooMuchAmmoHint;
var const localized string TooManyOfTheseHint;
var localized string GroupFullMessage, GroupFullMessage2A, GroupFullMessage2B, MeleeModeMessage;	// xPatch

var bool		bBumpStartsFight;			// If you have this weapon equipped and you bump into
											// a person with it, then they consider that starting a fight
											// with them. (You're aggressively holding the pistol, so if you
											// walk behind someone and bump them with it, they'll know
											// and start attacking you.)
var bool		bHideFoot;					// If true, then the weapon is too big, and when you kick
											// the foot isn't.

var travel bool	bLastSelected;				// Most recently selected weapon in subgroup.
											// If you selected the molotov out of grenades and scissors
											// then instead of picking the grenades when you pick
											// '6', it will pick the molotov again for you.

var float		CombatRating;				// How useful it is in the heat of combat. Some things like
											// matches are obviously not good, but neither is a cowhead
											// or a launcher in close combat. This should be vaguely around
											// 1.0 for each increment, so the shovel is 1.0 something
											// and the pistol is around 2.0. (not in the 100's in other words)


const SHOW_LINES=0;
const LEGAL_VIOLENCE_RANK	=	3;			// This is at or above shotgun, pistol and
											// below machine gun, rocket launcher, and all
const MAX_VIOLENCE_RANK		=	10.0;			// Highest violence rank

const INV_GROUP_FACTOR		=	1000;		// How much greater the Inventory grouping is, than the offset

var() string	FirstPersonMeshSuffix;		// Suffix of first person mesh to be used
var() string	WeaponsPackageStr;		// Name of weapons anim package

var() float		WeaponSpeedLoad;			// Speed of load animation (1.0 = normal)
var() float		WeaponSpeedReload;			// Speed of reload animation (1.0 = normal)
var() float		WeaponSpeedHolster;			// Speed of holster animation (1.0 = normal)
var() float		WeaponSpeedShoot1;			// Speed of shoot1 animation (1.0 = normal)
var() float		WeaponSpeedShoot1Rand;		// Extra randomized part that gets added to base speed
var() float		WeaponSpeedShoot2;			// Speed of shoot2 animation (1.0 = normal)
var() float		WeaponSpeedShoot2Rand;		// Extra randomized part that gets added to base speed
var() float		WeaponFirePitchStart;		// The weapon pitch for firing starts here...
var() float		WeaponFirePitchRand;		// and randomly adds some or all of this
var() float		WeaponSpeedIdle;			// Speed of idle animation (1.0 = normal)
var() Sound		AltFireSound;				// Sound alt fire makes when you shoot it
var() bool		bCanThrowMP;				// true for almost all weapons--only applicable during MP games
											// use bCanThrow for all games. BatonWeapon blocks all your weapons
											// from coming up in MP if you throw it, so don't allow it.

var bool bCannotBeStolen;	// True if this item can't be stolen (hands, map, urethra etc)


const SAME_WEAPON_RATING			=	0.21;
const REPLICATE_TIME_CHECK_IDLE		=	0.5;

// If they use SPH, use that instead of the auto fov in RenderOverlay
var bool bOverrideAutoFOV;

// Uses weapon-specific draw icon?
var() Texture OverrideHUDIcon;

// Holds playerfov
var float ControllerFOV;

// Fix for double-fire glitch
var float LastFireTimeSeconds;

var() bool bWeaponIsGross;		// "Gross" weapon flag. Set true for the cow head

var bool bAllowAimAssist;		// True if we want to allow aiming assistance

var() bool bContextualFireSwap;	// If the player has turned on "dual wield swap" and this is true, always swaps the Fire and AltFire functions.

///////////////////////////////////////////////////////////////////////////////
// Man Chrzan: xPatch 
///////////////////////////////////////////////////////////////////////////////

var byte bDropInVeteranMode;		// 0 - Ammo drop, 1 - weapon drop, 2 - randomly drop weapon or ammo.
var float VeteranModeDropChance;	// Chance for this weapon / it's ammo to drop.
var bool bAllowMiddleFinger;		// Thanks to this new bool we can show middle finger with any one-handed weapon. Like Glock for example.

// Reloading
var bool bReloadableWeapon;			// Set True if this weapon is ACTUAL reloadable weapon.
var bool bNoHudReticleReload;		// Set True if you crosshair to disappear during reload.
var bool bHideReloadCount;			// Set True if you don't want ReloadCount to be displayed on HUD.
var bool bAllowReloadHints;			// This decides if weapon is allowed to show reload hints or not (Permanent)
var travel bool bShowReloadHints;	// This will show reload hint for all weapons extending this class. 
									// Once player reloads manually (Reload function in P2Player) it gets disabled for all weapons.
var localized string ReloadHint1;

// Oldskool Hands
var bool bOldHands;					// For Debug 
var Mesh OldMesh;					// Old Mesh to use with the option enabled
var array<Texture> OldHandsSkins;	// Old skins we swap to
var Texture GimpHands, CopHands;	// Supported new skins we can also swap from
//var travel material	PreSwapTex;		// Keep pre-swap hands texture, for disabling the option.

// Settings Override
var bool xDisplayOverwrite;
var float xPreviousFOV;		// to save calculated fov
var float xDisplayFOV;
var float xOffsetX;
var float xOffsetY;
var float xOffsetZ;

// Customizable Muzzle Flash Emitter
var bool bSpawnMuzzleFlash;		// Set True if you want to use new Emitter MF system.
var bool bSpawnMuzzleSmoke;		// Set True if you want to use smoke effects.
var bool bMFNoAttach;			// Doesn't attach to bone, just spawn in it's location
var bool bMFAlwaysSpawn;		// Always spawns, even if previous effect still exists.
var bool bNoMFSetup;			// Spawns the emitter as it is, ignoring properties below.
var byte MFType;				// 0 Default, 1 Alternative, 2 None
var P2Emitter MF;
// 0 Primary Fire, 1 Alt Fire, 2 Optional Alternative Effects
var class<P2Emitter>  MFClass[3], SmokeClass;
var(MuzzleFlash) name MFBoneName;
var(MuzzleFlash) vector MFRelativeLocation;
var(MuzzleFlash) rotator MFRelativeRotation;
var(MuzzleFlash) Texture MFTex[3];
var(MuzzleFlash) range	MFScale[3];
var(MuzzleFlash) float	MFScaleTime[3];
var(MuzzleFlash) range	MFSizeRange[3];
var(MuzzleFlash) range	MFLifetime[3];
var(MuzzleFlash) range	MFSpinRan[3], MFSpinsPerSec[3];

// Shell
var P2ShellMaker SM;
var P2ShellCase shell;
var class<P2ShellCase> ShellClass;
var() name ShellBoneName;
var() vector ShellRelativeLocation;
var() float ShellSpeedY,ShellSpeedZ,ShellScale;
var texture InvShellTex, ShellTex;
var bool bCheckShell; 	   // If shell texture swap is needed

// Network replication
//
replication
{
	// Functions called by server on client
	reliable if( Role==ROLE_Authority )
		ClientWeaponThrown, ClientIdleCheckFire,
		ClientForceFinish;
	// client to server
	reliable if( Role < ROLE_Authority )
		ServerForceFinish;

	// Change by NickP: MP fix
	// Functions called by server on client
	reliable if( Role==ROLE_Authority )
		ClientInventoryAdded, ClientInventoryDeleted;
	// End
}

// DQ's shovel achievement (basically stick this in Fire on any weapon that isn't a shovel, clipboard, match, or urethra)
function DQShovel()
{
	// STUB -- we do this differently now
	/*
	if (PlayerController(Pawn(Owner).Controller) != None
		&& !Self.IsA('ClipboardWeapon')
		&& !Self.IsA('MatchesWeapon')	// allow the matches in case they get their dumb ass sent to jail
		&& !Self.IsA('ShovelWeapon')
		&& !Self.IsA('UrethraWeapon'))
		P2GameInfoSingle(Level.Game).TheGameState.bShovelEndingDQ = true;
	*/
}

///////////////////////////////////////////////////////////////////////////////
// Called after initiated
///////////////////////////////////////////////////////////////////////////////
simulated function PostBeginPlay()
{
	Super.PostBeginPlay();
	ShotCountReset();

	if(P2GameInfo(Level.Game) != None)
		bAllowDynamicLights = P2GameInfo(Level.Game).AllowDynamicWeaponLights();

	// Man Chrzan: xPatch
	GetReticleSettings();
	xSetupSettings();	
	//GetHandsSettings();
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function PostNetBeginPlay()
{
	local P2Pawn puse;

	Super.PostNetBeginPlay();

	// Hands/Foot textures and meshes are only set for MpPawns in multiplayer games.
	puse = P2Pawn(Owner);
	if(puse != None
		&& puse.HandsTexture != None)
		ChangeHandTexture(puse.HandsTexture,
			puse.DefaultHandsTexture,
			puse.FootTexture);

	GetReticleSettings();
	
	// Man Chrzan: xPatch
	xSetupSettings();	
	//GetHandsSettings();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function int GetRank()
	{
	return InventoryGroup * INV_GROUP_FACTOR + GroupOffset;
	}

///////////////////////////////////////////////////////////////////////////////
// This is called whenever the reticle is updated
///////////////////////////////////////////////////////////////////////////////
static simulated function ReticleUpdated(P2Player player)
	{
	local Inventory inv;

	log(Player$" ReticleUpdated ");
	if (player != None && player.Pawn != None)
		{
		// Tell all player's weapons to update their reticles
		inv = player.Pawn.Inventory;
		while (inv != None)
			{
			if (P2Weapon(inv) != None)
				P2Weapon(inv).GetReticleSettings();
			inv = inv.Inventory;
			}
		}
	}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function GetReticleSettings()
{
	local P2Player p2p;

	//log(self$" owner "$Owner$" cont "$Pawn(Owner).Controller);
	if(Owner != None)
	{
		p2p = P2Player(Pawn(Owner).Controller);

		if(p2p != None)
		{
			// Change by Man Chrzan: xPatch 2.0
			// Return only alpha + white color for old crosshair, it doesn't support color change.
			if(p2p.ReticleGroup == 0)
				ReticleDefaultColor = p2p.GetReticleColor();
			else
				ReticleDefaultColor = p2p.GetReticleColor2();
			ReticleColor = ReticleDefaultColor;
			ReticleTexture = p2p.GetReticleTexture();
			ReticleSize = p2p.ReticleSize;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// The first time this is added, this should be called, to do any extra
// setup
///////////////////////////////////////////////////////////////////////////////
function AddedToPawnInv(Pawn UsePawn, Controller UseCont)
{
	// STUB
}

///////////////////////////////////////////////////////////////////////////////
// Pretravel so you can clean up before the player goes to the next level
///////////////////////////////////////////////////////////////////////////////
function PreTravel()
{
}

///////////////////////////////////////////////////////////////////////////////
// When you're sent to jail most weapons are taken. The matches aren't. Perhaps
// they want to do something now.
///////////////////////////////////////////////////////////////////////////////
function AfterItsTaken(P2Pawn CheckPawn)
{
	// STUB
}

///////////////////////////////////////////////////////////////////////////////
// This is happening on a client, or the guy's machine who is running
// the listen server (no dedicated server)
///////////////////////////////////////////////////////////////////////////////
simulated function bool NotDedOnServer()
{
	//log(self$" net mode "$Level.NetMode$" role "$Role$" viewport "$ViewPort(PlayerController(Instigator.Controller).Player));

/*
	//ErikFOV Change: Fix problem
	// return (Level.NetMode == NM_Client
			// || Level.NetMode == NM_Standalone
			// || (Level.NetMode == NM_ListenServer
				// && Role == ROLE_Authority
				// && ViewPort(PlayerController(Instigator.Controller).Player) != None));
	return (Level.NetMode == NM_Client
		|| Level.NetMode == NM_Standalone
		|| (Level.NetMode == NM_ListenServer
			&& Role == ROLE_Authority
			&& (Instigator != None && !Instigator.bDeleteMe 
				&& Instigator.Controller != None 
				&& (PersonController(Instigator.Controller) != None 
					|| ViewPort(PlayerController(Instigator.Controller).Player) != None))));
	//end
*/

	// Change by NickP: MP fix
	return (Level.NetMode == NM_Client
			|| Level.NetMode == NM_Standalone
			|| (Level.NetMode == NM_DedicatedServer 
				&& Instigator != None 
				&& !Instigator.bDeleteMe 
				&& PersonController(Instigator.Controller) != None)
			|| (Level.NetMode == NM_ListenServer
				&& Role == ROLE_Authority
				&& (Instigator != None && !Instigator.bDeleteMe 
					&& (PersonController(Instigator.Controller) != None 
						|| ViewPort(PlayerController(Instigator.Controller).Player) != None))));
	// End
}

///////////////////////////////////////////////////////////////////////////////
// Grab the ammo and make it ready to be used. ((this was called by the
// p2player after someone wanted to pee with the P key (or whatever))
// And called by UrethraWeapon to turn it off)
///////////////////////////////////////////////////////////////////////////////
simulated function SetReadyForUse(bool bReady)
{
	P2AmmoInv(AmmoType).bReadyForUse = bReady;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function DetachFromPawn(Pawn P)
	{
	if ( ThirdPersonActor != None )
		{
		Pawn(Owner).DetachFromBone(ThirdPersonActor);
		ThirdPersonActor.Destroy();
		ThirdPersonActor = None;
		}
	}

///////////////////////////////////////////////////////////////////////////////
// Go through all your weapons and change out the hands texture for this new one
///////////////////////////////////////////////////////////////////////////////
simulated function ChangeHandTexture(Texture NewHandsTexture, Texture DefHandsTexture, Texture NewFootTexture)
{
	local int i;
	
	// xPatch: for old models handle texture change differently
	if(DoSwapHands()) {
		ChangeOldHandTexture(NewHandsTexture, DefHandsTexture, NewFootTexture);
		return;
	}
	
	for(i=0; i<Skins.Length; i++)
	{
		if(default.Skins[i] == DefHandsTexture)
		{
			Skins[i] = NewHandsTexture;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// Modify your speed based on your owners body speed
///////////////////////////////////////////////////////////////////////////////
function ChangeSpeed(float NewSpeed)
{
	WeaponSpeedLoad = default.WeaponSpeedLoad*NewSpeed;
	WeaponSpeedReload = default.WeaponSpeedReload*NewSpeed;
	WeaponSpeedHolster = default.WeaponSpeedHolster*NewSpeed;
	WeaponSpeedShoot1 = default.WeaponSpeedShoot1*NewSpeed;
	WeaponSpeedShoot2 = default.WeaponSpeedShoot2*NewSpeed;
}

///////////////////////////////////////////////////////////////////////////////
// Make sure the client unhooks things properly on its end.
///////////////////////////////////////////////////////////////////////////////
//simulated function ClientWeaponThrown()
//{
// It's not necessary to delete inventory on the client, and in fact, it causes
// problems because the inventory will already have been deleted on the server,
// which causes ugliness when the client tries to loop through the inventory chain.
// 	Instigator.DeleteInventory(self);
//	Instigator.DeleteInventory(AmmoType);
//}
simulated function ClientWeaponThrown()
{
//    Instigator.DeleteInventory(self);
//	if(AmmoType != None)
//		Instigator.DeleteInventory(AmmoType);
}


///////////////////////////////////////////////////////////////////////////////
// Toss this item out.
//
// Same as DropFrom in Inventory.uc, but we pass the instigator along to
// the spawned pickup as its owner, because we want to know who most recently
// dropped this for persistance
///////////////////////////////////////////////////////////////////////////////
function DropFrom(vector StartLocation)
{
	local Pickup P;
	local Inventory Inv;
	local bool bAmmoInUse;

	// 11/18 - don't drop weapons for a dead dude
	if ((Instigator.IsA('Dude') || Instigator.IsA('AWDude'))
		&& Instigator.Health <= 0)
		return;
		
	// xPatch: Ludicrous difficulty, not player.
	if (P2GameInfoSingle(Level.Game) != None
		&& P2GameInfoSingle(Level.Game).InVeteranMode()
		&& !Instigator.IsA('AWDude')
		&& !Instigator.IsA('Dude')
		&& !Instigator.IsA('AWZombie')	// Zombies can steal our AW weapons or have some useful stuff during final battle so they need to drop normally.
		)
	{
		// spawn ammo pickup instead, and only sometimes at that!
		if(FRand() <= VeteranModeDropChance)
		{
			// We might want grenades and some other stuff to be dropped.
			if(bDropInVeteranMode == 1 || (bDropInVeteranMode == 2 && FRand() <= 0.50))
			{
				P = spawn(PickupClass,Instigator,,StartLocation);
				// Give them weapon but with the bare minimum of ammo
				if(P2WeaponPickup(P) != None)
					P2WeaponPickup(P).AmmoGiveCount = class<P2WeaponPickup>(PickupClass).default.DeadNPCAmmoGiveRange.Min;
			}
			else // Otherwise we drop only it's ammo.
			{
				P = spawn(AmmoType.PickupClass,Instigator,,StartLocation);
				// Give them the bare minimum of ammo
				if(P2AmmoPickup(P) != None)
					P2AmmoPickup(P).AmmoAmount = class<P2WeaponPickup>(PickupClass).default.DeadNPCAmmoGiveRange.Min;
			}
		}
	}
	else // xPatch Change end here
	// spawn it earlier, so the instigator isn't cleared yet.
	P = spawn(PickupClass,Instigator,,StartLocation);

	if(P != None)
	{
		if(P != None)
			P.Instigator = Instigator;

		// Remove the weapon from the inventory
		if ( Instigator != None )
		{
			DetachFromPawn(Instigator);
		}
		
		// xPatch: For limited inventory we want to always keep ammo.
		// (so we can swap weapons and keep it between them)
		if (P2GameInfoSingle(Level.Game) != None 
			&& P2Player(Instigator.Controller) != None
			&& P2GameInfoSingle(Level.Game).GetPlayer().UseGroupLimit())
			bAmmoInUse = true;
		else // Remove the ammo from the inventory
			 // But only if it's not being used
			bAmmoInUse = false;
			
		if ( Instigator != None && !bAmmoInUse)
		{			
			for (Inv = Instigator.Inventory; Inv != None; Inv = Inv.Inventory)
			{				
				if (Inv != Self
					&& Weapon(Inv) != None
					&& Weapon(Inv).AmmoType == AmmoType)
				{
					bAmmoInUse = true;
					break;
				}
			}
			
			if (!bAmmoInUse)
				AmmoType.DetachFromPawn(Instigator);
		}

		ClientWeaponThrown();
		if(Level.Game != None
			&& Level.Game.bIsSinglePlayer)
		{
			Instigator.DeleteInventory(self);
			// Only clear this out too if your still alive, if not
			// then don't clear it because it will break the link in
			// P2GameInfo as DiscardInventory drops everything (and
			// it wouldn't matter anyway, because your dead).
			// If we don't have this, then in SP you can drop your weapons
			// and pick them back up for double the ammo--bad!
			if(Instigator.Health > 0)
			{
				if(AmmoType != None
					&& !bAmmoInUse)
					Instigator.DeleteInventory(AmmoType);
			}
		}

		SetDefaultDisplayProperties();
		Inventory = None;
		StopAnimating();
		bTossedOut = true;
		if(P != None)
		{
			P2WeaponPickup(P).bTossedOut=true;
			P.InitDroppedPickupFor(self);
			if(!P.bDeleteMe)
				P.Velocity = Velocity;
		}

		Velocity = vect(0,0,0);
		Instigator = None;
		Destroy();
	}
}

///////////////////////////////////////////////////////////////////////////////
// Reset it to here so that it will notify controllers as soon as you shoot it
// Set it to one below the max, because as it shoots, it increments ShotCount
// first, making it equal to the max.
///////////////////////////////////////////////////////////////////////////////
function ShotCountReset()
	{
	ShotCount=ShotCountMaxForNotify-1;
	}

///////////////////////////////////////////////////////////////////////////////
// ViolenceRank in the form of a float between or equal to 0.0 and 1.0
///////////////////////////////////////////////////////////////////////////////
function float GetViolenceRatio()
{
	return (ViolenceRank/MAX_VIOLENCE_RANK);
}

///////////////////////////////////////////////////////////////////////////////
// ViolenceRank in the form of a float between or equal to 0.0 and 1.0
///////////////////////////////////////////////////////////////////////////////
function float FindViolenceRatio(float UseRank)
{
	return (UseRank/MAX_VIOLENCE_RANK);
}

///////////////////////////////////////////////////////////////////////////////
// Just a little randomness for the pitch, around 1.0
///////////////////////////////////////////////////////////////////////////////
function float GetRandPitch()
{
	return (0.96 + FRand()*0.08);
}

///////////////////////////////////////////////////////////////////////////////
// Tell whoever which weapon they really want
///////////////////////////////////////////////////////////////////////////////
simulated function Weapon RecommendWeapon( out float rating )
	{
	local P2Weapon Recommended;
	local float oldRating, oldFiring;
	local int oldMode;

	if ( Instigator.IsHumanControlled() )
		rating = SwitchPriority();
	else if(Instigator.Controller != None)
		{
		rating = RateSelf();
		if ( (self == Instigator.Weapon) && (Instigator.Controller.Enemy != None)
			//&& AmmoType.HasAmmo()		// xPatch: 
			&& HasAmmo()				// Reloading support
			&& ViolenceRank > 0
			&& !bMeleeWeapon)
			// tend to stick with same weapon, if it's violent and not melee (because those are very weak
			rating += SAME_WEAPON_RATING;
		rating += Instigator.Controller.WeaponPreference(self);
		}
	if ( inventory != None )
		{
		Recommended = P2Weapon(inventory.RecommendWeapon(oldRating));
		if ( (Recommended != None) && (oldRating > rating) )
			{
			rating = oldRating;
			// DEBUGGING
			//			if(Recommended.ViolenceRank == 0)
			//				SwitchPriority();
			return Recommended;
			}
		}
	// DEBUGGING
	//	if(ViolenceRank == 0)
	//		SwitchPriority();
	return self;
	}

///////////////////////////////////////////////////////////////////////////////
// true if you have a player controller and behind view is true
///////////////////////////////////////////////////////////////////////////////
function bool IsFirstPersonView()
	{
	if(Instigator != None
		&& PlayerController(Instigator.Controller) != None)
		{
		return !PlayerController(Instigator.Controller).bBehindView;
		}

	return false;
	}

///////////////////////////////////////////////////////////////////////////////
// Attach to pawn
///////////////////////////////////////////////////////////////////////////////
simulated function AttachToPawn(Pawn P)
	{
	//if(!IsFirstPersonView())
	if(AttachmentClass != None)
		Super.AttachToPawn(P);	// you're an AI controller, so definitely use this
	}

///////////////////////////////////////////////////////////////////////////////
// This will randomly change the color and the size of the dynamic
// light associate with the flash. Change in each weapon's file,
// but call each time you start up the flash again.
// This function is also used by the third-person muzzle flash, so the
// colors will look the same
//
// NOTES on color values. Just in case you don't know about Epic's Brightness,
// Hue, and Saturation setup (I didn't) it goes like this: Hue is the color.
// Saturation is basically how white something is. So Brightness at 255 and
// Saturation at 255 will leave Hue meaningless. You can set it to whatever,
// but not color other than white will generally show through. But setting
// Saturation to around 150, on muzzle flashes at least, will let you set Hue
// (between 0 and 255) and still get color.
///////////////////////////////////////////////////////////////////////////////
simulated function PickLightValues()
	{
	}

///////////////////////////////////////////////////////////////////////////////
// BotFire()
//  called by NPC firing weapon.  Weapon chooses appropriate firing mode to use (typically no change)
//  bFinished should only be true if called from the Finished() function
//  FiringMode can be passed in to specify a firing mode (used by scripted sequences)
//
// This was copied from Weapon but changed a lot.
///////////////////////////////////////////////////////////////////////////////
function bool BotFire(bool bFinished, optional name FiringMode)
{
	if ( !bFinished && !IsIdle() )
		return false;
	Instigator.Controller.bFire = 1;
	Instigator.Controller.bAltFire = 0;


	Fire(1.0);


	/*
	if ( !RepeatFire() )
		Global.ServerFire();
	else if ( StopFiringTime < Level.TimeSeconds + 0.3 )
	{
		StopFiringTime = Level.TimeSeconds + 0.6;
		Global.ServerRapidFire();
	}
	// in some situations, weapon might want to call CauseAltFire() instead, and set bAltFire=1
	*/
	return true;
}

///////////////////////////////////////////////////////////////////////////////
// Reports if the weapon is currently in a firing/violent state
///////////////////////////////////////////////////////////////////////////////
function bool IsFiring()
{
	if(IsInState('NormalFire')
		|| IsInState('AltFireState'))
		return true;

	return false;
}

///////////////////////////////////////////////////////////////////////////////
// Make sure you're in range to use this weapon
///////////////////////////////////////////////////////////////////////////////
function bool CanAttack(Actor Other)
{
	local float MaxDist, CheckDist;
	local vector HitLocation, HitNormal,X,Y,Z, projStart;
	local actor HitActor;

	if ( (Instigator == None) || (Instigator.Controller == None) )
		return false;

	// Check that target is within range
	if(bMeleeWeapon)
		// Doubling the max range may make the NPC's a little less accurate with melee weapons (only about 25% of the time)
		// but it fixes an exploitable situation where if you kick a cop, and then slowly *walk* away from them
		// without a weapon out, when the get out their batons, they won't continously try to run to you're last
		// point, they'll run and then try to bonk you and usually hit you. If you don't use the player's
		// last location (and use the player instead) then the cops will psychically home in on the player anywhere.
		MaxDist = 2*MaxRange;
	else
		MaxDist = TraceDist;

	if ( VSize(Instigator.Location - Other.Location) > MaxDist )
		return false;

	return true;
}

///////////////////////////////////////////////////////////////////////////////
// Same as original, but we remove ReloadCount
// Don't do reloadcount because we usually force reloads (grenades) or don't
// do them at all (machinegun)
///////////////////////////////////////////////////////////////////////////////
function ServerFire()
{
	DQShovel();

	// Double-fire glitch fix
	LastFireTimeSeconds=Level.TimeSeconds;

	if ( AmmoType == None )
	{
		// ammocheck
		log("WARNING "$self$" HAS NO AMMO!!!");
		GiveAmmo(Pawn(Owner));
	}

	//log(self$" serverfire, ammo "$AmmoType.AmmoAmount$" get state "$GetStateName());

	//if ( AmmoType.HasAmmo() )
	if ( HasAmmo() )	// xPatch: Reloading support
	{
		GotoState('NormalFire');

		// Don't do reloadcount because we usually force reloads (grenades) or don't
		// do them at all (machinegun)
		if(bReloadableWeapon)	// xPatch: We DO reloadcount now, but only for bReloadableWeapon 
			ReloadCount--;
		
		if ( AmmoType.bInstantHit )
			TraceFire(TraceAccuracy,0,0);
		else
			ProjectileFire();
		LocalFire();
	}
}

///////////////////////////////////////////////////////////////////////////////
// Same as original, but we remove ReloadCount
// Don't do reloadcount because we usually force reloads (grenades) or don't
// do them at all (machinegun)
///////////////////////////////////////////////////////////////////////////////
simulated function Fire( float Value )
{
	//log(self$" Fire, ammo "$AmmoType.AmmoAmount);
	if ( AmmoType == None
	//	|| !AmmoType.HasAmmo() )
		|| !HasAmmo() )				// xPatch: Reloading support
	{
		ClientForceFinish();
		ServerForceFinish();
		return;
	}

	if ( !RepeatFire() )
		ServerFire();
	else if ( StopFiringTime < Level.TimeSeconds + 0.3 )
	{
		StopFiringTime = Level.TimeSeconds + 0.6;
		ServerRapidFire();
	}
	if ( Role < ROLE_Authority )
	{
		// Don't do reloadcount because we usually force reloads (grenades) or don't
		// do them at all (machinegun)
		if(bReloadableWeapon)	// xPatch: We DO reloadcount now, but only for bReloadableWeapon 
			ReloadCount--;
		LocalFire();
		//log(self$" going to client firing");
		GotoState('ClientFiring');
	}
}

///////////////////////////////////////////////////////////////////////////////
// Called on client's side to make the gun fire
// Check here to throw out danger markers to let people know the gun has gone
// off.
///////////////////////////////////////////////////////////////////////////////
simulated function LocalFire()
	{
	local P2Player P;

	//log(self$" local fire ");
	bPointing = true;

	if ( Instigator != None)
		{
		if(Instigator.IsLocallyControlled() )
			{
			P = P2Player(Instigator.Controller);
			if (P!=None)
				{
				if ( InstFlash != 0.0 )
					P.ClientInstantFlash( InstFlash, InstFog);

				P.ShakeView(ShakeRotMag, ShakeRotRate, ShakeRotTime,
							ShakeOffsetMag, ShakeOffsetRate, ShakeOffsetTime);
				}
			}
		}
	if ( Affector != None )
		Affector.FireEffect();
	PlayFiring();
	}

///////////////////////////////////////////////////////////////////////////////
// Normal trace fire, plus check where to make the danger marker to
// alert people of the noise.
///////////////////////////////////////////////////////////////////////////////
function TraceFire( float Accuracy, float YOffset, float ZOffset )
	{
	local vector markerpos, markerpos2;
	local bool secondary;
	local BulletTracer bullt;
	local vector usev, Extent;
	local Rotator newrot;
	local Pawn P;

	// Weapon.TraceFire (modified to save where it hit inside LastHitLocation
	local vector HitNormal, StartTrace, EndTrace, EndTracePerfect, X,Y,Z;
	local vector TempHit, TempNormal;
	local actor Other, AimAssistHit;
	local float AimAngle;

	//StopWatchStart('TraceFire');

	Owner.MakeNoise(1.0);
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	StartTrace = GetFireStart(X,Y,Z);
	AdjustedAim = Instigator.AdjustAim(AmmoType, StartTrace, 2*AimError);
	EndTrace = StartTrace + (YOffset + Accuracy * (FRand() - 0.5 ) ) * Y * 1000
		+ (ZOffset + Accuracy * (FRand() - 0.5 )) * Z * 1000;
	X = vector(AdjustedAim);
	EndTrace += (TraceDist * X);
	EndTracePerfect = StartTrace + TraceDist * X;
	
	// This performs the collision but also records where it hit
	Other = Trace(LastHitLocation,HitNormal,EndTrace,StartTrace,True);
	// if AutoAim is on and we didn't hit anything (like a car or something), trace in a "cone" and prefer pawn targets.
	// Never do this in multiplayer, though, and only for player owners
	if (bAllowAimAssist && (Other == None || Other.bStatic) && Level.NetMode == NM_Standalone && Level.Game.AutoAim < 1 && 
		Owner != None && Pawn(Owner) != None && Pawn(Owner).Controller != None && Pawn(Owner).Controller.bIsPlayer)
	{
		// Offloaded this shit to the C++, where actor iteration is much, much faster.
		//StopWatchStart('AutoAim');
		AimAssistHit = GetAssistedAimTarget(StartTrace, TraceDist);
		if (AimAssistHit != None)
		{
			Other = AimAssistHit;
			//PlayerController(Pawn(Owner).Controller).ClientMessage("["$Level.TimeSeconds$"] AutoAim assist hit '"$Other$"'");
		}
		//StopWatchStop('AutoAim');
		/*
		//StopWatchStart('ForEach');
		foreach VisibleCollidingActors(class'Pawn', P, TraceDist, StartTrace)
		{
			if (P != Instigator && P != None)
			{
				//StopWatchStart('Hit');
				AimAngle = ACos(Vector(Instigator.GetViewRotation()) dot Normal(P.Location - StartTrace));
				//log("Angle to"@P@AimAngle);
				// If we hit something, break out and say that was what we shot at.
				if (AimAngle < 1 - Level.Game.AutoAim)
				{
					PlayerController(Pawn(Owner).Controller).ClientMessage("["$Level.TimeSeconds$"] AutoAim assist hit '"$P$"'");
					Other = P;
					LastHitLocation = TempHit;
					HitNormal = TempNormal;
					//StopWatchStop('Hit');
					break;
				}
				//StopWatchStop('Hit');
			}
		}
		//StopWatchStop('ForEach');		
		*/

		/*
		//StopWatchStart('ExtentTrace');
		Extent.X = 1000.0;
		Extent.Y = 1000.0;
		Extent.Z = 0.0;
		foreach TraceActors(class'Pawn', P, TempHit, TempNormal, EndTracePerfect, StartTrace, Extent)
		{
			// If we hit something, break out and say that was what we shot at.
			if (P != None)
			{
				AimAngle = ACos(Vector(Instigator.GetViewRotation()) dot Normal(P.Location - StartTrace));
				log("Angle to"@P@AimAngle);
				// If we hit something, break out and say that was what we shot at.
				if (AimAngle < 1 - Level.Game.AutoAim)
				{
					PlayerController(Pawn(Owner).Controller).ClientMessage("["$Level.TimeSeconds$"] AutoAim assist hit '"$P$"'");
					Other = P;
					LastHitLocation = TempHit;
					HitNormal = TempNormal;
					break;
				}
			}
		}		
		//StopWatchStop('ExtentTrace');
		*/
	}

	AmmoType.ProcessTraceHit(self, Other, LastHitLocation, HitNormal, X,Y,Z);
	// Say we just fired
	ShotCount++;

	// Only show tracers if the user wants it, and if he's not the player
	// in first person (so show 3rd person player tracers if wanted)
	if(P2GameInfo(Level.Game).bShowTracers)
//		&& (P2Player(Instigator.Controller) == None
//			|| P2Player(Instigator.Controller).bBehindView))
	{
		// Make a tracer through the air (this is only for the single player side
		// of things. And inferior version gets made in MP in an effect maker pack)
		usev = (LastHitLocation - StartTrace);
		if(Level.Game != None
			&& FPSGameInfo(Level.Game).bIsSinglePlayer)
		{
			bullt = spawn(class'BulletTracer',Owner,,(LastHitLocation + StartTrace)/2);
			bullt.SetDirection(Normal(usev), VSize(usev));
		}
	}

	// Set your enemy as the one you attacked.
	if(P2Player(Instigator.Controller) != None
		&& FPSPawn(Other) != None)
	{
		P2Player(Instigator.Controller).Enemy = FPSPawn(Other);
	}

	// Only make a new danger marker if the consecutive fires were as high
	// as the max
	if(ShotCount >= ShotCountMaxForNotify
		&& Instigator.Controller != None)
		{
		// tell it we know this just happened, by recording it.
		ShotCount -= ShotCountMaxForNotify;

		// Records the first (gun fire)
		markerpos = Instigator.Location;
		// Secondary records the bullet hit
		markerpos2 = LastHitLocation;
		secondary = true;

		// Primary (the gun shooting, making a loud noise)
		if(ShotMarkerMade != None)
			{
			ShotMarkerMade.static.NotifyControllersStatic(
				Level,
				ShotMarkerMade,
				FPSPawn(Instigator),
				FPSPawn(Instigator),
				ShotMarkerMade.default.CollisionRadius,
				markerpos);
			}

		// This is if a pawn is hit by a bullet (or hurt bad), so it's really scary
		if(P2Pawn(Other) != None
			&& PawnHitMarkerMade != None)
			{
			PawnHitMarkerMade.static.NotifyControllersStatic(
				Level,
				PawnHitMarkerMade,
				FPSPawn(Instigator),
				FPSPawn(Other),
				PawnHitMarkerMade.default.CollisionRadius,
				markerpos2);
			}
		// secondary (if bullet hit something other than a man, like a wall)
		else if(secondary
			&& BulletHitMarkerMade != None)
			{
			BulletHitMarkerMade.static.NotifyControllersStatic(
				Level,
				BulletHitMarkerMade,
				FPSPawn(Instigator),
				None,
				BulletHitMarkerMade.default.CollisionRadius,
				markerpos2);
			}
		}
	//StopWatchStop('TraceFire');
	}

///////////////////////////////////////////////////////////////////////////////
// Alt trace fire, plus check where to make the danger marker to
// alert people of the noise.
///////////////////////////////////////////////////////////////////////////////
function TraceAltFire( float Accuracy, float YOffset, float ZOffset )
{
}

///////////////////////////////////////////////////////////////////////////////
// clean up however
///////////////////////////////////////////////////////////////////////////////
simulated function bool ForceEndFire()
	{
	// Turn off muzzle flash stuff
	bMuzzleFlash=false;
	// Don't mess with bDrawMuzzleFlash.. that only gets set once in default properties
	return true;
	}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function bool HasAmmo()
{
	if(AmmoType != None)
	{
		if(bReloadableWeapon)	// xPatch: Reloading Support
			return (P2AmmoInv(AmmoType).bInfinite || AmmoType.AmmoAmount > 0 || ReloadCount > 0);
		else
			return AmmoType.HasAmmo();
	}
	else
		return false;
}

///////////////////////////////////////////////////////////////////////////////
// Normal projectile fire, plus check where to make the danger marker to
// alert people of the noise.
///////////////////////////////////////////////////////////////////////////////
function ProjectileFire()
{
	local vector markerpos;
	local Vector Start, X,Y,Z;

	Owner.MakeNoise(1.0);
	GetAxes(Instigator.GetViewRotation(),X,Y,Z);
	Start = GetFireStart(X,Y,Z);
	AdjustedAim = Instigator.AdjustAim(AmmoType, Start, AimError);
	AmmoType.SpawnProjectile(Start,AdjustedAim);

	// Only make a new danger marker if the consecutive fires were as high
	// as the max
	if(ShotCount >= ShotCountMaxForNotify
		&& Instigator.Controller != None
		&& ShotMarkerMade != None)
	{
		// tell it we know this just happened, by recording it.
		ShotCount -= ShotCountMaxForNotify;

		// Records the first (gun fire)
		markerpos = Instigator.Location;

		// Primary (the gun shooting, making a loud noise)
		if(ShotMarkerMade != None)
		{
			ShotMarkerMade.static.NotifyControllersStatic(
				Level,
				ShotMarkerMade,
				FPSPawn(Instigator),
				None,
				ShotMarkerMade.default.CollisionRadius,
				markerpos);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// Alt projectile fire, plus check where to make the danger marker to
// alert people of the noise.
///////////////////////////////////////////////////////////////////////////////
function ProjectileAltFire()
{
}

///////////////////////////////////////////////////////////////////////////////
// Return the switch priority of the weapon (normally AutoSwitchPriority, but may be
// modified by environment (or by other factors for bots)
///////////////////////////////////////////////////////////////////////////////
simulated function float SwitchPriority()
	{
	local float temp;

	//if(AmmoType != None
	//	&& Pawn(Owner) != None)
	//	log(self$" SwitchPriority, ammo "$AmmoType.AmmoAmount$" has self "$(Pawn(Owner).Weapon == self));

	if (Instigator != None
		&& !Instigator.IsHumanControlled() )
		return RateSelf();
	else if ( !bJustMade
		//&& (AmmoType != None && !AmmoType.HasAmmo()) ) 
		&& (AmmoType != None && !HasAmmo()) )	// xPatch: Reloading support
		{
		if ( Pawn(Owner).Weapon == self )
			return -0.5;
		else
			return -1;
		}
	else
	// We want to change the value in Urethra and have it access that and
	// not the default. We don't change it otherwise, so it works fine to access the actual variable
	// There was no reason in our version to access default instead of just the variable.
	//		return default.AutoSwitchPriority;
		return AutoSwitchPriority;
	}

///////////////////////////////////////////////////////////////////////////////
// Sets appropriate weapon configuration, and returns rating based on that configuration
// If it was just made it uses autoswitchpriority
///////////////////////////////////////////////////////////////////////////////
function float RateSelf()
	{
	if ( AmmoType == None || !HasAmmo() )
		{
		if(!bJustMade)
			return -2;
		else
			return default.AutoSwitchPriority;
		}
	return (AIRating + (FRand() * 0.02));
	}

///////////////////////////////////////////////////////////////////////////////
// Get the style to use for holding this weapon.
///////////////////////////////////////////////////////////////////////////////
simulated function EWeaponHoldStyle GetHoldStyle()
	{
	return holdstyle;
	}

///////////////////////////////////////////////////////////////////////////////
// Get the style to use for switching this weapon.
///////////////////////////////////////////////////////////////////////////////
simulated function EWeaponHoldStyle GetSwitchStyle()
	{
	return switchstyle;
	}

///////////////////////////////////////////////////////////////////////////////
// Get the style to use for firing this weapon.
///////////////////////////////////////////////////////////////////////////////
simulated function EWeaponHoldStyle GetFiringStyle()
	{
	return firingstyle;
	}

///////////////////////////////////////////////////////////////////////////////
// Set right handed mesh
//
// Don't allow this to happen in MP--it screws up our short sleeved meshes by
// setting the mesh again on the client.
///////////////////////////////////////////////////////////////////////////////
simulated function SetRightHandedMesh()
{
	local P2MocapPawn p;
	local String strMesh;
	local Mesh meshNew;
	// STUB OUT--meshes up textures on hands in SP also.
/*
	if(Level.Game != None
		&& Level.Game.bIsSinglePlayer)
	{
		if(Instigator != None && PlayerController(Instigator.Controller) != None)
			{
			p = P2MocapPawn(Instigator);
			if (p != None)
				{
				// pawn specifies prefix, which selects the type of arms to be used
				if (p.FirstPersonMeshPrefix != ""
					&& FirstPersonMeshSuffix != "")
					{
					// combine with weapon which specifies suffix, which is weapon type
					strMesh = WeaponsPackageStr $ p.FirstPersonMeshPrefix $ FirstPersonMeshSuffix;
					// load the mesh
					meshNew = Mesh(DynamicLoadObject(strMesh, class'Mesh'));
					}
				}
			}

		if (meshNew != None)
			LinkMesh(meshNew);
		else
			LinkMesh(default.Mesh);
	}
	*/
	
	// xPatch: Classic Hands
	if(DoSwapHands())
		SwapHandsOld();
	else
		SwapHandsNew();
}

///////////////////////////////////////////////////////////////////////////////
// Compare self to current weapon.  If better than current weapon, then switch
///////////////////////////////////////////////////////////////////////////////
simulated function ClientWeaponSet(bool bOptionalSet)
{
	local weapon W;

	Instigator = Pawn(Owner); //weapon's instigator isn't replicated to client
	if ( Instigator == None )
	{
		GotoState('PendingClientWeaponSet');
		return;
	}
	else if ( IsInState('PendingClientWeaponSet') )
		GotoState('');
	if ( Instigator.Weapon == self )
		return;

	if ( Instigator.Weapon == None )
	{
		Instigator.PendingWeapon = self;
		Instigator.ChangedWeapon();
		return;
	}
	if ( bOptionalSet && (Instigator.IsHumanControlled() && PlayerController(Instigator.Controller).bNeverSwitchOnPickup) )
		return;
	if ( Instigator.Weapon.SwitchPriority() < SwitchPriority() )
	{
		W = Instigator.PendingWeapon;
		Instigator.PendingWeapon = self;
		GotoState('');

		if ( !Instigator.Weapon.PutDown() )
		{
			Instigator.PendingWeapon = W;
		}
		return;
	}
	GotoState('');
}



///////////////////////////////////////////////////////////////////////////////
// Giving Other this weapon
///////////////////////////////////////////////////////////////////////////////
function GiveTo(Pawn Other)
{
	// Instead of calling the Super for this function, let's copy Inventory.GiveTo
	// here, because we're trying to override Weapon.GiveTo while keeping Inventory.GiveTo
	//Super.GiveTo(Other);
	Instigator = Other;
	Other.AddInventory( Self );
	GotoState('');

	bTossedOut = false;
	Instigator = Other;

	//	GiveAmmo(Other);
	ClientWeaponSet(true);

	if(bMeleeWeapon
		&& P2Pawn(Other) != None)
	{
		if(P2Player(P2Pawn(Other).Controller) != None)
			UseMeleeDist = PlayerMeleeDist;
		else
			UseMeleeDist = NPCMeleeDist;
	}

	//  Check if your hints should be active
	if(P2GameInfoSingle(Level.Game) != None
		&& P2GameInfoSingle(Level.Game).TheGameState != None
		&& P2GameInfoSingle(Level.Game).TheGameState.FoundInvHintInactive(GetRank()))
		bAllowHints=false;
}

///////////////////////////////////////////////////////////////////////////////
//Override the base weapon version of this, to make
// sure we use AddAmmo in both spots
///////////////////////////////////////////////////////////////////////////////
function GiveAmmoFromPickup( Pawn Other, int AddInAmount)
{
	if ( AmmoName == None
		|| Other == None)
		return;
	//log(self@"give ammo from pickup ammoname"@ammoname);
	AmmoType = Ammunition(Other.FindInventoryType(AmmoName));
	//log("found"@ammotype);

	// Add in the ammo necessary on a pickup.
	if ( AmmoType != None )
	{
		AmmoType.AddAmmo(AddInAmount);
	}
	else
	{
		AmmoType = Spawn(AmmoName);	// Create ammo type required
		Other.AddInventory(AmmoType);		// and add to player's inventory
		AmmoType.AddAmmo(AddInAmount); // Use it here, even though we just made this ammotype.
	}


	// Check to set this to infinite ammo if NPC's are using this weapon
	if(Other.Controller != None
		&& P2Player(Other.Controller) == None)
	{
		if(bMakeInfiniteForNPCs)
			P2AmmoInv(AmmoType).bInfinite=true;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Happens after you switch levels.
//
// This was taken from Weapon.uc but modified to not need PickupAmmoCount.
//
///////////////////////////////////////////////////////////////////////////////
event TravelPostAccept()
{
	local int AmmoGive;

//	Super.TravelPostAccept();
	// To replace this we copied the internal TravelPostAccept calls from all
	// the parent classes of this. It was only from Inventory.uc.
	PickupFunction(Pawn(Owner));

	// Now call the rest of the normal function
	if ( Pawn(Owner) == None )
		return;
	if ( AmmoName != None )
	{
		AmmoType = Ammunition(Pawn(Owner).FindInventoryType(AmmoName));
		if ( AmmoType == None )
		{
			AmmoType = Spawn(AmmoName);	// Create ammo type required
			Pawn(Owner).AddInventory(AmmoType);		// and add to player's inventory

			if(PickupClass != None)
			{
				// Multiplayer has different balancing for how much ammo you get with things
				if(Level.Game != None
					&& FPSGameInfo(Level.Game).bIsSinglePlayer)
					AmmoGive=class<P2WeaponPickup>(PickupClass).default.AmmoGiveCount;
				else
					AmmoGive=class<P2WeaponPickup>(PickupClass).default.MPAmmoGiveCount;
			}

			AmmoType.AmmoAmount = AmmoGive;

			AmmoType.GotoState('');
		}
	}
	if ( self == Pawn(Owner).Weapon )
	{
		BringUp();
		Pawn(Owner).ServerChangedWeapon(None, self); // xPatch: fix for missing weapon attachment after level transition
	}
	else GotoState('');
}

///////////////////////////////////////////////////////////////////////////////
// HandlePickupQuery()
// If picking up another weapon of the same class, add its ammo.
// If ammo count was at zero, check if+ should auto-switch to this weapon.
//
// This was taken mostly from Weapon.uc, but has the added ammo pickup number
// being take from the pickup itself, instead of the weapon.
///////////////////////////////////////////////////////////////////////////////
function bool HandlePickupQuery( Pickup Item )
{
	local int OldAmmo, NewAmmo;
	local Pawn P;

	if (Item.class == ErrandPickupClass)
	{
		return false;
	}
	// Handle both long and short sleeved weapons--don't use ClassIsChildOf or you'll get wacky
	// things to happen like grenades turning into molotovs and such.
	else if (Class == Item.InventoryType
			|| (P2WeaponPickup(Item) != None
				&& Class == P2WeaponPickup(Item).ShortSleeveType))
	{
		if ( WeaponPickup(item).bWeaponStay && ((P2WeaponPickup(Item) == None) || !P2WeaponPickup(Item).bTossedOut) )
			return true;
		P = Pawn(Owner);

		if ( P2AmmoInv(AmmoType) != None )
		{
			// Don't let you pick up multiple versions of something that has infinite ammo (like a shovel)
			if(P2AmmoInv(AmmoType).bInfinite)
			{
				if(P2Player(Instigator.Controller) != None)
					P2Player(Instigator.Controller).MyHUD.LocalizedMessage(class'PickupMessagePlus', ,,,,TooManyOfTheseHint);
				return true;
			}
			// Don't let you pick up more of the same thing than you already need
			else if (AmmoType.AmmoAmount==AmmoType.MaxAmmo)
			{
				if(P2Player(Instigator.Controller) != None)
					P2Player(Instigator.Controller).MyHUD.LocalizedMessage(class'PickupMessagePlus', ,,,,TooMuchAmmoHint);
				return true;
			}
			else
			{

				OldAmmo = AmmoType.AmmoAmount;
				if( Item != None)
				{
					// Multiplayer has different balancing for how much ammo you get with things
					if(Level.Game != None
						&& FPSGameInfo(Level.Game).bIsSinglePlayer)
						NewAmmo = P2WeaponPickup(Item).AmmoGiveCount;
					else
						NewAmmo = P2WeaponPickup(Item).MPAmmoGiveCount;
				}
				else
				{
					// Multiplayer has different balancing for how much ammo you get with things
					if(Level.Game != None
						&& FPSGameInfo(Level.Game).bIsSinglePlayer)
						NewAmmo = P2WeaponPickup(Item).default.AmmoGiveCount;
					else
						NewAmmo = P2WeaponPickup(Item).default.MPAmmoGiveCount;
				}

				if ( AmmoType.AddAmmo(NewAmmo) && (OldAmmo == 0)
					&& (P.Weapon.class != item.InventoryType) )
				{
					/*
					if ( P2GameInfoMulti(Level.Game) != None )
					{
						log(self$" weapon is waiting");
						GotoState('PendingClientWeaponSet');
					}
					else
					{
					*/
						ClientWeaponSet(true);
					//}
				}
			}
		}
		Item.AnnouncePickup(Pawn(Owner));
		return true;
	}
	if ( Inventory == None )
		return false;

	return Inventory.HandlePickupQuery(Item);
}

///////////////////////////////////////////////////////////////////////////////
// Play firing animation/sound/etc
///////////////////////////////////////////////////////////////////////////////
simulated function PlayFiring()
{
	SetupMuzzleFlashEmitter(); // Man Chrzan: xPatch
	IncrementFlashCount();
	// Play MP sounds on everyone's computers
	if(Level.Game == None
		|| !FPSGameInfo(Level.Game).bIsSinglePlayer)
		PlayOwnedSound(FireSound,SLOT_Interact,1.0,,,WeaponFirePitchStart + (FRand()*WeaponFirePitchRand),false);
	else // just on yours in SP games
		Instigator.PlaySound(FireSound, SLOT_None, 1.0, true, , WeaponFirePitchStart + (FRand()*WeaponFirePitchRand));
	PlayAnim('Shoot1', WeaponSpeedShoot1 + (WeaponSpeedShoot1Rand*FRand()), 0.05);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function PlayAltFiring()
{
	SetupMuzzleFlashEmitter(); // Man Chrzan: xPatch
	IncrementFlashCount();
	// Play MP sounds on everyone's computers
	if(Level.Game == None
		|| !FPSGameInfo(Level.Game).bIsSinglePlayer)
		PlayOwnedSound(AltFireSound,SLOT_Interact,1.0,,,WeaponFirePitchStart + (FRand()*WeaponFirePitchRand),false);
	else // just on yours in SP games
		Instigator.PlaySound(AltFireSound, SLOT_None, 1.0, true, , WeaponFirePitchStart + (FRand()*WeaponFirePitchRand));

	PlayAnim('Shoot2', WeaponSpeedShoot2, 0.05);
}

///////////////////////////////////////////////////////////////////////////////
// Play our proper idling animation
///////////////////////////////////////////////////////////////////////////////
simulated function PlayIdleAnim()
{
	PlayAnim('Idle', WeaponSpeedIdle, 0.0);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function PlayDownAnim()
{
	// If our instigator is on fire, then put away you're weapons super fast,
	// and don't even play a third-person anim, but only for NPC's
	if(FPSPawn(Instigator).MyBodyFire != None)
		//&& PlayerController(Instigator.Controller) == None)
	{
		PlayAnim('Holster', 1000.0, 0.0);
	}
	else
	{
		PlayAnim('Holster', WeaponSpeedHolster, 0.05);
		Instigator.PlaySound(HolsterSound, SLOT_Misc, 1.0);
		// Show the pawn putting away the weapon
		P2MoCapPawn(Instigator).PlayWeaponDown();
	}
}

///////////////////////////////////////////////////////////////////////////////
// animation blend to down
///////////////////////////////////////////////////////////////////////////////
simulated function TweenDown()
	{
	local name Anim;
	local float frame,rate;

	if ( IsAnimating() && AnimIsInGroup(0,'Select') )
		{
		GetAnimParams(0,Anim,frame,rate);
		TweenAnim( Anim, frame * 0.4 );
		}
	else
		{
			PlayDownAnim();
		}
	}

///////////////////////////////////////////////////////////////////////////////
// play reloading sounds
///////////////////////////////////////////////////////////////////////////////
simulated function PlayReloading()
	{
	PlayAnim('Reload', WeaponSpeedReload, 0.05);
	Instigator.PlaySound(ReloadSound, SLOT_Misc, 1.0);
	}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function name GetPlaySelectAnim()
{
	return 'Load';
}

///////////////////////////////////////////////////////////////////////////////
// Play select sounds
///////////////////////////////////////////////////////////////////////////////
simulated function PlaySelect()
{
	local bool bPlaySelect;
	bForceFire = false;
	bForceAltFire = false;

	if ( !IsAnimating() || !AnimIsInGroup(0,GetPlaySelectAnim()) )
	{
		PlayAnim(GetPlaySelectAnim(), WeaponSpeedLoad, 0.0);
	}

	if((P2Player(Instigator.Controller) == None
		|| !P2Pawn(Instigator).bPlayerStarting)
		&& Level.TimeSeconds - P2Pawn(Instigator).SpawnTime > 1.0)
	{
		//log(self@"playing select sound for"@Instigator@"spawned"@P2Pawn(Instigator).SpawnTime);
		Instigator.PlaySound(SelectSound, SLOT_Misc, 1.0);
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
function ServerAltFire()
{
	if ( AmmoType == None )
	{
		log("WARNING "$self$" HAS NO AMMO!!!");
		GiveAmmo(Pawn(Owner));
	}
	//if(AmmoType.HasAmmo()
	if ( HasAmmo() 	// xPatch: Reloading Support
		&& bUsesAltFire)
	{
		bAltFiring=true;

		GotoState('NormalFire');
		ReloadCount--;
		if ( AmmoType.bInstantHit )
			TraceAltFire(TraceAccuracy,0,0);
		else
			ProjectileAltFire();
		LocalAltFire();
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function AltFire( float Value )
{
	//if ( !AmmoType.HasAmmo() )
	if (  !HasAmmo() )	// xPatch: Reloading Support
		return;

	if ( !RepeatFire() )
		ServerAltFire();
//	else
//	if ( StopFiringTime < Level.TimeSeconds + 0.3 )
//	{
//		StopFiringTime = Level.TimeSeconds + 0.6;
//		ServerRapidFire();
//	}
	if ( Role < ROLE_Authority
		&& bUsesAltFire)
	{
		ReloadCount--;
		LocalAltFire();
		GotoState('ClientFiring');
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
simulated function LocalAltFire()
{
	local PlayerController P;

	bPointing = true;

	if ( (Instigator != None) && Instigator.IsLocallyControlled() )
	{
		P = PlayerController(Instigator.Controller);
		if (P!=None)
		{
			if ( InstFlash != 0.0 )
				P.ClientInstantFlash( InstFlash, InstFog);

			P.ShakeView(ShakeRotMag, ShakeRotRate, ShakeRotTime,
						ShakeOffsetMag, ShakeOffsetRate, ShakeOffsetTime);
		}
	}
	if ( Affector != None )
		Affector.FireEffect();
	PlayAltFiring();
}

///////////////////////////////////////////////////////////////////////////////
// Make sure we change our animations for each weird weapon
///////////////////////////////////////////////////////////////////////////////
simulated function BringUp()
	{
	Super.BringUp();

	if(Instigator != None)
		Instigator.ChangeAnimation();
	}

///////////////////////////////////////////////////////////////////////////////
// Return true, if you want the next weapon search to continue, false if you
// want it to abort (perhaps you'll do something else)
///////////////////////////////////////////////////////////////////////////////
simulated function bool AllowNextWeapon()
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////
// Return true, if you want the previous weapon search to continue, false if you
// want it to abort (perhaps you'll do something else)
///////////////////////////////////////////////////////////////////////////////
simulated function bool AllowPrevWeapon()
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
function CauseAltFire()
{
	Global.ServerAltFire();
}

///////////////////////////////////////////////////////////////////////////////
// Zooms scope in
///////////////////////////////////////////////////////////////////////////////
simulated function ZoomIn()
{
}

///////////////////////////////////////////////////////////////////////////////
// Zooms scope out
///////////////////////////////////////////////////////////////////////////////
simulated function ZoomOut()
{
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
function bool DoServerFireAgain(bool bForce)
{
	if(Level.Game != None
		&& FPSGameInfo(Level.Game).bIsSinglePlayer)
		return ((StopFiringTime > Level.TimeSeconds) || bForce
		//|| Instigator.PressingFire()
		);
	else
		return ((StopFiringTime > Level.TimeSeconds) || bForce
		//|| Instigator.PressingFire()
		);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
function bool DoServerAltFireAgain(bool bForceAlt)
{
	if(Level.Game != None
		&& FPSGameInfo(Level.Game).bIsSinglePlayer)
		return ( bForceAlt
		//|| Instigator.PressingAltFire()
		);
	else
		return ( bForceAlt
		//|| Instigator.PressingAltFire()
		);
}

///////////////////////////////////////////////////////////////////////////////
// Something went wrong and we need to force the weapon to change
// Hopes to fix the 0 ammo weapon bug
///////////////////////////////////////////////////////////////////////////////
function ForceFinish()
{
	warn(self$" force finish called "$GetStateName()$" ammo "$AmmoType.AmmoAmount);
	Finish();
	ClientForceFinish();
}
// Called by client to be run on server
function ServerForceFinish()
{
	warn(self$" server force finish called "$GetStateName()$" ammo "$AmmoType.AmmoAmount);
	Finish();
}

///////////////////////////////////////////////////////////////////////////////
// Something went wrong and we need to force the weapon to change
///////////////////////////////////////////////////////////////////////////////
simulated function ClientForceFinish()
{
	warn(self$" client force Idle called "$GetStateName()$" ammotype "$AmmoType$" ammo "$AmmoType.AmmoAmount);
	ClientFinish();
}

///////////////////////////////////////////////////////////////////////////////
// Finish a sequence
///////////////////////////////////////////////////////////////////////////////
function Finish()
{
	local bool bForce, bForceAlt;

	//log(self$" Finish get state name "$GetStateName()$" ammo amount "$AmmoType.AmmoAmount);
	//if ( NeedsToReload() && P2AmmoInv(AmmoType).HasAmmoFinished() )
	if ( NeedsToReload() && HasAmmoFinished() ) 	// xPatch: Reloading Support
	{
		GotoState('Reloading');
		return;
	}

	bForce = bForceFire;
	bForceAlt = bForceAltFire;
	bForceFire = false;
	bForceAltFire = false;

	if ( bChangeWeapon )
	{
		GotoState('DownWeapon');
		return;
	}

	if ( (Instigator == None) || (Instigator.Controller == None) )
	{
		GotoState('');
		return;
	}

	if ( !Instigator.IsHumanControlled() )
	{
		//if ( !P2AmmoInv(AmmoType).HasAmmoFinished() )
		if ( !HasAmmoFinished() )	// xPatch: Reloading Support
		{
			// AI find it's next best weapon
			Instigator.Controller.SwitchToBestWeapon();

			if ( bChangeWeapon )
				GotoState('DownWeapon');
			else
				GotoState('Idle');
		}
		
		// ACTION_Shoot
		if ( AIController(Instigator.Controller) != None
			&& Instigator.Controller.IsInState('Scripting') )
		{
			if ( !AIController(Instigator.Controller).WeaponFireAgain(AmmoType.RefireRate,true) )
			{
				if ( bChangeWeapon )
					GotoState('DownWeapon');
				else
					GotoState('Idle');
			}
			else
				Global.ServerFire();
			return;
		}

		if ( Instigator.PressingFire() && (FRand() <= AmmoType.RefireRate) )
			Global.ServerFire();
		else if ( Instigator.PressingAltFire() )
			CauseAltFire();
		else
		{
			//log(self$" stop firing, finish ");
			Instigator.Controller.StopFiring();
			GotoState('Idle');
		}
		return;
	}

	//if ( !P2AmmoInv(AmmoType).HasAmmoFinished() && Instigator.IsLocallyControlled() )
	if ( !HasAmmoFinished() && Instigator.IsLocallyControlled() )	// xPatch: Reloading Support
	{
		// If you autoswitch, you go to the next strongest weapon you have,
		// if not, then go back to your hands.
		if(P2Player(Instigator.Controller) != None
			&& P2Player(Instigator.Controller).bAutoSwitchOnEmpty)
			P2Player(Instigator.Controller).SwitchAfterOutOfAmmo();
		else if(P2Player(Instigator.Controller) != None)
			P2Player(Instigator.Controller).SwitchToHands(true);

		//log(self$" bchangeweapon "$bChangeWeapon$" state "$NoAmmoChangeState);
		if ( bChangeWeapon )
		{
			GotoState(NoAmmoChangeState);
			return;
		}
		else
			GotoState('Idle');
	}
	if ( Instigator.Weapon != self )
		GotoState('Idle');
	else if (DoServerFireAgain(bForce))
	{
		Global.ServerFire();
	}
	else if (DoServerAltFireAgain(bForceAlt))
		CauseAltFire();
	else
		GotoState('Idle');
}

///////////////////////////////////////////////////////////////////////////////
// Client only--Weapon done shooting
///////////////////////////////////////////////////////////////////////////////
simulated function ClientFinish()
{
	//log(self$" ClientFinish get state name "$GetStateName()$" ammo amount "$AmmoType.AmmoAmount);
	if ( (Instigator == None) || (Instigator.Controller == None) )
	{
		GotoState('');
		return;
	}
	//if ( NeedsToReload() && P2AmmoInv(AmmoType).HasAmmoFinished() )
	if ( NeedsToReload() && HasAmmoFinished() )	// xPatch: Reloading Support
	{
		GotoState('Reloading');
		return;
	}

	//if ( !P2AmmoInv(AmmoType).HasAmmoFinished() )
	if ( !HasAmmoFinished() )	// xPatch: Reloading Support
	{
		// If you autoswitch, you go to the next strongest weapon you have,
		// if not, then go back to your hands.
		if(P2Player(Instigator.Controller) != None
			&& P2Player(Instigator.Controller).bAutoSwitchOnEmpty)
			Instigator.Controller.SwitchToBestWeapon();
		else if(P2Player(Instigator.Controller) != None)
			P2Player(Instigator.Controller).SwitchToHands(true);

		if ( bChangeWeapon )
		{
			GotoState(NoAmmoChangeState);
			return;
		}
		else
		{
			PlayIdleAnim();
			GotoState('Idle');
			return;
		}
	}
	if ( bChangeWeapon )
	{
		//TweenDown();
		GotoState('DownWeapon');
	}
	else if ( Instigator.PressingFire() )
	{
		Global.Fire(0);
	}
	else
	{
		if ( Instigator.PressingAltFire() )
			Global.AltFire(0);
		else
		{
			PlayIdleAnim();
			GotoState('Idle');
		}
	}
}
/*
///////////////////////////////////////////////////////////////////////////////
// Zeroes flash count so when the next gun is brought up, a residual flash
// doesn't happen on him
///////////////////////////////////////////////////////////////////////////////
simulated function ZeroFlashCount()
{
	FlashCount=0;
	if ( WeaponAttachment(ThirdPersonActor) != None )
	{
		WeaponAttachment(ThirdPersonActor).FlashCount = FlashCount;
        WeaponAttachment(ThirdPersonActor).ThirdPersonEffects();
	}
}
*/
///////////////////////////////////////////////////////////////////////////////
// Give hints about the cops and this weapon
///////////////////////////////////////////////////////////////////////////////
function bool GetCopHints(out String str1, out String str2)
{
	local P2Player p2p;

	if(Instigator != None)
	{
		p2p = P2Player(Instigator.Controller);

		if(p2p != None
			&& p2p.bShowWeaponHints)
		{
			// This type of weapon is one in which cops will arrest you even if you
			// have it out (like your hands). But you may be playing a trick on them,
			// by having switched from a violent weapon. So they'll tell you to drop
			// your old weapon, if you are playing with them.
			if(bArrestableWeapon)
			{
				if(p2p.LastWeaponSeen != None)
				{
					str1 = DropWeaponHint1;
					str2 = DropWeaponHint2;
					return true;
				}
				else
				{
					str1=StandStillHint;
					return true;
				}
			}
			else // A violent weapon that can be dropped and the cops want you to drop
			{
				str1 = DropWeaponHint1;
				str2 = DropWeaponHint2;
				return true;
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// Give hints about this item
///////////////////////////////////////////////////////////////////////////////
function bool GetHints(out String str1, out String str2, out String str3,
				out byte InfiniteHintTime)
{
	// Change by Man Chrzan: xPatch 2.0	
	// Show new reload hints
	if (ReloadCount < Default.ReloadCount
		&& AmmoType.AmmoAmount > 0
		&& bShowReloadHints 
		&& bAllowReloadHints)
	{
		str1=ReloadHint1;
		return true;
	}
	// Show regular hints
	else if(bShowHints
		&& bAllowHints)
	{
		str1=HudHint1;
		str2=HudHint2;
		str3=HudHint3;
		return true;
	}
	return false;
}

///////////////////////////////////////////////////////////////////////////////
// Allow hints again
///////////////////////////////////////////////////////////////////////////////
function RefreshHints()
{
	bAllowHints=true;
}

///////////////////////////////////////////////////////////////////////////////
// Don't show HudHint any more
///////////////////////////////////////////////////////////////////////////////
function TurnOffHint()
{
	if(bAllowHints
		&& P2GameInfoSingle(Level.Game) != None
		&& P2GameInfoSingle(Level.Game).TheGameState != None)
	{
		bAllowHints=false;
		// Tell the gamestate to save that this is turned off
		P2GameInfoSingle(Level.Game).TheGameState.RegisterInventoryHint(GetRank());
		UpdateHudHints();
	}
}

///////////////////////////////////////////////////////////////////////////////
// Tell the hud what hints to render
///////////////////////////////////////////////////////////////////////////////
function UpdateHudHints()
{
	local P2Player p2p;
	local String str1, str2, str3;
	local byte InfiniteHintTime;

	if(Instigator != None)
	{
		p2p = P2Player(Instigator.Controller);
		if(p2p != None
			&& P2Hud(p2p.MyHud) != None)
		{
			GetHints(str1, str2, str3, InfiniteHintTime);
			P2Hud(p2p.MyHud).SetWeapHints(str1, str2, str3, InfiniteHintTime);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// Draw your crosshairs
///////////////////////////////////////////////////////////////////////////////
simulated function DrawCrossHair( canvas Canvas)
{
	local P2Player p2p;
	local float UseScale;

	if (!bNoHudReticle)
	{
		p2p = P2Player(Instigator.Controller);
		if (ReticleTexture != None && p2p != None)
		{
			// Draw reticle
			if(ReticleSize != 0) // xPatch Change
				UseScale = ReticleSize; 
			else // End
				UseScale = P2Hud(p2p.MyHud).Scale;

			Canvas.Style = ERenderStyle.STY_Alpha;
			Canvas.DrawColor = ReticleColor;
			CrossHair = ReticleTexture;
			Canvas.SetPos(
				(Canvas.ClipX / 2) - UseScale*(CrossHair.USize/2),
				(Canvas.ClipY / 2) - UseScale*(CrossHair.VSize/2));
			Canvas.DrawIcon(CrossHair, UseScale);
		}
	}
}

//=============================================================================
// Weapon rendering
// Draw first person view of inventory
simulated event RenderOverlays( canvas Canvas )
{
	local rotator NewRot;
	local bool bPlayerOwner;
	local int Hand;
	local  PlayerController PlayerOwner;
	local float ScaledFlash;
	// debug vars
	local color tempcolor;
	local vector HitNormal, StartTrace, EndTrace, X,Y,Z;
	local actor Other;
	local Vector Res;
	local float Aspect;

    // We need something to match the controller so it's not constantly setting the fov.
	//ControllerFOV = 0;

    // Checks for Ultra WS and corrections draw scale, fov, and position.
    // Sorry for the hacky method, but cannot seem to fix the view model clipping.
    //ApplyPositionHack(0.25,133,vect(2.0000,0.000000,-3.0000),,,);

	if (bDeleteMe)
		return;

	if ( Instigator == None )
		return;
		
	// xPatch: It's now handled with HUD by default.
	if(!P2Player(Instigator.Controller).bHUDCrosshair)
		DrawCrosshair(Canvas);

	PlayerOwner = PlayerController(Instigator.Controller);

	if ( PlayerOwner != None )
	{
		bPlayerOwner = true;
		Hand = PlayerOwner.Handedness;
		if (  Hand == 2 )
			return;
	}

    // Find the correct view model FOV
    if(!bOverrideAutoFOV)
    {
        if(ControllerFOV != PlayerOwner.DefaultFOV)
	    {
			// Approximation, the old method was pulling some weird shit in lower aspect ratios. Should be more consistent across aspects now.
	        ControllerFOV = PlayerOwner.DefaultFOV;
			
			Res = PlayerOwner.GetResolution();
			Aspect = Res.X / Res.Y;
			// 4:3 (1.333333) = Standard - 65
			// 1.6 = 72.5
			// 5:3 (1.666667) = 74
			// 16:9 (1.777778) = Widescreen - 75
			// 21:9 (2.333333) = Ultra-Widescreen - 88
			// 5.333333 = Triple-Head - 121
			
			// Approximates correct display FOV based on aspect ratio.
			if (Aspect <= 1.8)
				DisplayFOV = 23.f * Aspect + 36.333333;
			else
			{
				DisplayFOV = -99.555555/Aspect + 139.666666;
				// Push the view model down a bit on ultra-wide aspect ratios
				PlayerViewOffset.Z = Default.PlayerViewOffset.Z - 2;
			}
			//log("Aspect"@Aspect@"DisplayFOV"@DisplayFOV);
        }
    }

	if ( bMuzzleFlash && bDrawMuzzleFlash && (MFTexture != None) )
	{
		if ( !bSetFlashTime )
		{
			bSetFlashTime = true;
			FlashTime = 0;//Level.TimeSeconds + FlashLength;
		}
		else if (FlashTime >= FlashMax) //( FlashTime < Level.TimeSeconds )
		{
			bMuzzleFlash = false;
			// RWS Change 06/03/02
			// This is so guns with flashes will turn off their dynamic light
			// when the flash is supposed to be over--this is for first-person mode only.
			// The actual setup for the lighting and all is handled usually in SetupMuzzleFlash in the
			// weapons.
			// Also, I added it to here, because it's only one line, easy to move around and keep track of
			// instead of overriding this giant function and copying everything over, just to add this line.
			bDynamicLight=false;
			// RWS Change 06/03/02
		}
		if ( bMuzzleFlash )
		{
			ScaledFlash = 0.5 * MuzzleFlashSize * MuzzleScale * Canvas.ClipX/640.0;
			Canvas.SetPos(0.5*Canvas.ClipX - ScaledFlash + Canvas.ClipX * Hand * FlashOffsetX, 0.5*Canvas.ClipY - ScaledFlash + Canvas.ClipY * FlashOffsetY);
			DrawMuzzleFlash(Canvas);
			FlashTime+=1.0;
		}
	}
	else
		bSetFlashTime = false;
		
	// Man Chrzan: xPatch Overwrite Weapons FOV
	if(xDisplayOverwrite)
	{
		if(xPreviousFOV == 0)
			xPreviousFOV = DisplayFOV;
		
		DisplayFOV = xPreviousFOV + xDisplayFOV;
		
		PlayerViewOffset.X = Default.PlayerViewOffset.X + xOffsetX;
		PlayerViewOffset.Y = Default.PlayerViewOffset.Y + xOffsetY;
		PlayerViewOffset.Z = Default.PlayerViewOffset.Z + xOffsetZ;
	}
	// End

	// clear z buffer to get muzzle flash behind hands correctly (doesn't work--not sure what else to do)
	Canvas.DrawActor(None, false, true);
	SetLocation( Instigator.Location + Instigator.CalcDrawOffset(self) );
	NewRot = Instigator.GetViewRotation();

	if ( Hand == 0 )
		newRot.Roll = 2 * Default.Rotation.Roll;
	else
		newRot.Roll = Default.Rotation.Roll * Hand;

	setRotation(newRot);
	Canvas.DrawActor(self, false, false, DisplayFOV);

	// DEBUG WORK
	if(SHOW_LINES==1)
	{
		GetAxes(Instigator.GetViewRotation(),X,Y,Z);
		StartTrace = GetFireStart(X,Y,Z);
		AdjustedAim = Instigator.AdjustAim(AmmoType, StartTrace, 2*AimError);
		EndTrace = StartTrace + (TraceAccuracy * (FRand() - 0.5 ) ) * Y * 1000
			+ (TraceAccuracy * (FRand() - 0.5 )) * Z * 1000;
		X = vector(AdjustedAim);
		EndTrace += (TraceDist * X);

		tempcolor.G=255;
		Canvas.DrawColor = tempcolor;
		Canvas.Draw3DLine(StartTrace, EndTrace);
	}
}

///////////////////////////////////////////////////////////////////////////////
// Get called on the client, waiting for if the guy is holding down the fire
// button while we're idle. If he's not and we're in Idle mode and he then
// presses it, it will register instantly. We just have to be ready for
// if the fire button is already pressed on the way into Idle.
//
//		NOTE
// This used to be called via a timer in Idle. But it seems that simply
// calling this once idle starts, everything is fine. Which is very good
// since calling this replicated function all the time on a timer would have
// slowed things down for sure.
///////////////////////////////////////////////////////////////////////////////
simulated function ClientIdleCheckFire()
{
	//log(self$" ClientIdleCheckFire timer idle, fire "$Instigator.PressingFire()$" bfire "$Instigator.Controller.bFire);
	if ( Instigator.PressingFire() ) Fire(0.0);
	if ( Instigator.PressingAltFire() ) AltFire(0.0);
	if(Instigator.Weapon == self)
		SetTimer(REPLICATE_TIME_CHECK_IDLE, false);
}

///////////////////////////////////////////////////////////////////////////////
// Get firing mode as string "burst" "auto" etc.
///////////////////////////////////////////////////////////////////////////////
simulated function string GetFiringMode()
{
	// STUB -- filled out on weapons that use it
	return "";
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Weapon is up and ready to fire, but not firing.
// extends original, to keep track of shot count
// Uses the same code below it's Begin:, except we use HasAmmoFinished for
// special weapons (like the shocker) that never want to switch, but need
// to recharge eventually.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state Idle
{
	simulated function bool PutDown()
	{
		GotoState('DownWeapon');
		return True;
	}

	///////////////////////////////////////////////////////////////////////////////
	// Reset shot count if you're not still firing
	///////////////////////////////////////////////////////////////////////////////
	simulated function BeginState()
	{
		//log(self$" begin state "$GetStateName());
		Super.BeginState();

		// If the player is not pressing fire, reset the shotcount for notifies
		if(!Instigator.PressingFire()
			&& FPSPawn(Instigator).bPlayer)
			ShotCountReset();
		if (Instigator.Weapon == self)
			ClientIdleCheckFire();
	}

	///////////////////////////////////////////////////////////////////////////////
	// If you're multiplayer, then turn off your timer
	///////////////////////////////////////////////////////////////////////////////
	simulated function EndState()
	{
		Super.EndState();
		//if ( P2GameInfoMulti(Level.Game) != None )
		//	SetTimer(-10.0, false);
	}

Begin:
	bPointing=False;
	//if ( NeedsToReload() && P2AmmoInv(AmmoType).HasAmmoFinished() )
	if ( NeedsToReload() && HasAmmoFinished() )	// xPatch: Reloading Support
		GotoState('Reloading');
	//if ( !P2AmmoInv(AmmoType).HasAmmoFinished() )	
	if ( !HasAmmoFinished() )	// xPatch: Reloading Support
		Instigator.Controller.SwitchToBestWeapon();  //Goto Weapon that has Ammo
	if ( Instigator.PressingFire() )
	{
		Fire(0.0);
	}
	if ( Instigator.PressingAltFire() ) AltFire(0.0);
	PlayIdleAnim();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// NormalFire
//
// If you ever make an ALTNORMALFIRE, please update IsFiring to include it...
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state NormalFire
{
	// Double-fire glitch fix
	function AnimEnd(int Channel)
	{
		if (LastFireTimeSeconds != Level.TimeSeconds)
			Super.AnimEnd(Channel);
	}

	simulated function Fire(float F)
	{
		//log(self$" normal fire ");
		if ( AmmoType == None
		//	|| !AmmoType.HasAmmo() )
			|| !HasAmmo() )				// xPatch: Reloading support
		{
			ClientForceFinish();
			ServerForceFinish();
			return;
		}
	}

	simulated function AltFire(float F)
	{
		Fire(F);
	}

	function CheckAnimating()
	{
		if ( !IsAnimating() )
		{
			warn(self$" stuck in NormalFire and not animating!");
			ForceFinish();
		}
	}

	simulated function beginstate()
	{
		//log(self$" begin state "$GetStateName());
		super.beginstate();
	}

	function EndState()
	{
		//log(self$" end state "$GetStateName());
		if ( Instigator != None )
			Instigator.StopPlayFiring();
		Super.EndState();
		bAltFiring=false;
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state ClientFiring
{
	simulated function Fire(float F)
	{
		//log(self$" fire client firing");
		if ( AmmoType == None
		//	|| !AmmoType.HasAmmo() )
			|| !HasAmmo() )				// xPatch: Reloading support
		{
			ClientForceFinish();
			ServerForceFinish();
			return;
		}
	}

	simulated function AltFire(float F)
	{
		Fire(F);
	}

	simulated function beginstate()
	{
		//log(self$" begin state "$GetStateName());
		super.beginstate();
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// DownWeapon
// Make sure if you're told to put down a weapon when already putting down
// one, you short circuit and say it's down now.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state DownWeapon
{
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	simulated function bool PutDown()
	{
		Pawn(Owner).ChangedWeapon();
		return true;
	}

	///////////////////////////////////////////////////////////////////////////////
	// If you have any ammo left, make sure to show you're third person representation
	// of you're weapon (like a grenade, or so, pistol doesn't hide ever, so this doesn't matter
	// for it)
	///////////////////////////////////////////////////////////////////////////////
	simulated function BeginState()
	{
		//if(AmmoType.HasAmmo()
		if( HasAmmo()	// xPatch: Reloading Support
			&& ThirdPersonActor != None)
			ThirdPersonActor.bHidden=false;

		// This was last selected in it's group
		if(Instigator.PendingWeapon != None
			&& Instigator.PendingWeapon.InventoryGroup == InventoryGroup)
			bLastSelected = false;

		Super.BeginState();
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Active
// Make sure if you're told to put down the weapon that you're currently
// bringing up, then say you've changed it automatically so it can't move on.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state Active
{
	simulated function bool PutDown()
	{
		Pawn(Owner).ChangedWeapon();
		GotoState('');
		return true;
	}

	function EndState()
	{
		Super.EndState();
		
		if (ShellClass != None)	// xPatch: Shells
			SetupShell();		
	}

	///////////////////////////////////////////////////////////////////////////////
	// Turn off the last selected bool as it changes.
	///////////////////////////////////////////////////////////////////////////////
	function BeginState()
	{
		local Inventory inv;

		//log(self$" begin state "$GetStateName());
		// Go through and for all the other weapons in this
		// group that have bLastSelected true, set it to false.
		inv = Instigator.Inventory;
		while(inv != None)
		{
			if(P2Weapon(inv) != None
				&& inv != self
				&& P2Weapon(inv).InventoryGroup == InventoryGroup)
			{
				P2Weapon(inv).bLastSelected=false;
			}
			inv = inv.Inventory;
		}

		// This was last selected in it's group, so it to true
		bLastSelected = true;
		Super.BeginState();
		UpdateHudHints();
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// EmptyDownWeapon
// For grenades, thrown things, napalm launcher, where he must put away
// an empty or non-existant weapon (like he's got nothing in his hands)
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state EmptyDownWeapon extends DownWeapon
{
	ignores PutDown;

	simulated function AnimEnd(int Channel)
	{
		// We don't want the Super version to tell the
		// pawn ChangedWeapon again since we do it on the start of this state.

		CheckAnimating();
	}

	simulated function BeginState()
	{
		//log(self$" begin state "$GetStateName());
		Super.BeginState();

		// Removed this for MP. Used to make weapons come up twice in MP when you
		// run out, then walk back over it.
		Pawn(Owner).ChangedWeapon();
	}
}

// Helper function. Allows me to test out positions without recompiling every darn second!
exec function SPH(int ValX, int ValY, int ValZ, float FOV)
{
 local float AspectRatio;
 local vector Offset;
 local  PlayerController PlayerOwner;

 if ( Instigator == None )
	return;



 PlayerOwner = PlayerController(Instigator.Controller);

 if ( FOV == 0.00)
 {
   log("Client tried to set FOV as zero.");
   PlayerOwner.ClientMessage("FOV cannot be zero!");
   PlayerOwner.ClientMessage("Call like SPH 1 0 -10 80.00");
   return;
 }

 Offset.X = float(ValX);
 Offset.Y = float(ValY);
 Offset.Z = float(ValZ);


 AspectRatio = 0;

 self.DisplayFOV=FOV; // 60.0
 self.PlayerViewOffset=Offset;

  // To the log!
 log("Weapon position values for "$ItemName);
 log("FOV:     "$DisplayFOV);
 log("Offset: ("$PlayerViewOffset.X$","$PlayerViewOffset.Y$","$PlayerViewOffset.Z$")");

 // Show the player what he's done.
 PlayerOwner.ClientMessage("Weapon position set for "$ItemName);
 PlayerOwner.ClientMessage("FOV:     "$DisplayFOV);
 PlayerOwner.ClientMessage("Offset: ("$PlayerViewOffset.X$","$PlayerViewOffset.Y$","$PlayerViewOffset.Z$")");

 bOverrideAutoFOV = true;

 //log(DrawScale);
 //log(DisplayFOV);
 //log(PlayerViewOffset);
}

// Helper function. Allows me to get the values for a current weapon. Probably helpful for others.
exec function GPH()
{
 local  PlayerController PlayerOwner;

 if ( Instigator == None )
	return;

 PlayerOwner = PlayerController(Instigator.Controller);

 // To the log!
 log("Weapon position values for "$ItemName);
 log("FOV:     "$DisplayFOV);
 log("Offset: ("$PlayerViewOffset.X$","$PlayerViewOffset.Y$","$PlayerViewOffset.Z$")");

 // Show the player what he's done.
 PlayerOwner.ClientMessage("Weapon position values for "$ItemName);
 PlayerOwner.ClientMessage("FOV:     "$DisplayFOV);
 PlayerOwner.ClientMessage("Offset: ("$PlayerViewOffset.X$","$PlayerViewOffset.Y$","$PlayerViewOffset.Z$")");
}

///////////////////////////////////////////////////////////////////////////////
// PL - Made this a global P2Weapon function. This way any P2Weapon can be
// set as a "zooming" weapon, and won't interfere with the weapon selector.
///////////////////////////////////////////////////////////////////////////////
simulated function bool IsZoomed()
{
	return false;
}

// Change by NickP: MP fix
simulated function ClientInventoryAdded()
{
	if(Role < ROLE_Authority 
		&& Pawn(Owner) != None 
		&& Pawn(Owner).Controller != None)
		Pawn(Owner).Controller.NotifyAddInventory(self);
}

simulated function ClientInventoryDeleted(Actor OldOwner)
{
	if(Role < ROLE_Authority 
		&& Pawn(OldOwner) != None 
		&& Pawn(OldOwner).Controller != None)
		Pawn(OldOwner).Controller.NotifyDeleteInventory(self);
}
// End


//=====================================================================================
// Added by Man Chrzan: xPatch
// NEW NEW Muzzle Flash System
//=====================================================================================

///////////////////////////////////////////////////////////////////////////////
// Setup for old 2013 Update firing effects ("Alternative") option. 
///////////////////////////////////////////////////////////////////////////////
function SetupAltMuzzleFlash(int NewType)
{
	MFType = NewType;
	
	if(MFType == 2)
		bSpawnMuzzleFlash=True;
}

///////////////////////////////////////////////////////////////////////////////
// Decides which effects to spawn
///////////////////////////////////////////////////////////////////////////////
simulated function SetupMuzzleFlashEmitter() 
{
	if (IsFirstPersonView() && bSpawnMuzzleFlash)
	{
		// Spawn Effect
		if(bAltFiring && MFClass[1] != none)
			PlayFireEffects(MFClass[1], 1);
		else 
		{
			if (MFType == 1 && MFClass[2] != None)
				PlayFireEffects(MFClass[2], 2); 
			else
				PlayFireEffects(MFClass[0], 0);
		}
	}
}

simulated function PlayFireEffects(class<P2Emitter> MyMFClass, optional int SetNum)
{
	local int i;
	local vector SpawnPos;
	local vector SpawnDir;
	local P2Emitter MF;
	local Rotator R;
	local vector V;
	
	// Debug 
	//P2Player(Owner.Controller).ClientMessage("Fire Effects");
	
	// Spawn only if it disappeared - unless AlwaysSpawn bool is true.
	if (MyMFClass != none 
		&& (MF == none || bMFAlwaysSpawn))
	{
		if(bMFNoAttach) 
		{
			SpawnPos = GetBoneCoords(MFBoneName).Origin;
			SpawnDir = GetBoneCoords(MFBoneName).XAxis;
			MF = Spawn(MyMFClass,,, SpawnPos, Rotator(SpawnDir));
		}
		else
			MF = Spawn( MyMFClass );
		
		// If it's xMuzzleFlashEmitter we can setup some exta stuff.
		if( xMuzzleFlashEmitter(MF) != None)
		{
			if(Level.Game.bIsSinglePlayer && P2GameInfoSingle(Level.Game).xManager.bDynamicLights)
				xMuzzleFlashEmitter(MF).SetDynamicLight();
			
			if(!bNoMFSetup) {
				xMuzzleFlashEmitter(MF).SetEmitterTexture(MFTex[SetNum]);
				xMuzzleFlashEmitter(MF).SetEmitterScale(MFScale[SetNum].Min, MFScale[SetNum].Max, MFScaleTime[SetNum]);
				xMuzzleFlashEmitter(MF).SetEmitterSize(MFSizeRange[SetNum].Min, MFSizeRange[SetNum].Max);
				xMuzzleFlashEmitter(MF).SetEmitterLifetime(MFLifetime[SetNum].Min, MFLifetime[SetNum].Max);
				xMuzzleFlashEmitter(MF).SetEmitterSpin(MFSpinRan[SetNum], MFSpinsPerSec[SetNum]);	
			}
		}
		
		// Random position and rotation stuff	
		//V = MFRelativeLocation;
		//V.Z += (frand() * 2) - 1;
		//V.X += (frand() * 2) - 1;
		//V.Y += (frand() * 2) - 1;
		
		// Basic setup for any P2Emitter
		MF.SetOwner( Owner );
		if(!bMFNoAttach)
			AttachToBone( MF, MFBoneName );
		MF.SetDirection(vector(Rotation), 0.0);
		MF.SetRelativeRotation(MFRelativeRotation);
		MF.SetRelativeLocation(MFRelativeLocation);

		// Disable upon completion of effect
		for( i=0; i < MF.Emitters.Length; i++ )
			MF.Emitters[i].AutoDestroy = true; 
	}
}

///////////////////////////////////////////////////////////////////////////////
// Called by xMuzzleFlashEmitter
///////////////////////////////////////////////////////////////////////////////
function SetupWeaponGlow(byte FlashGlow) 
{
	local int FinalGlow;
	
	if(FlashGlow == 0)
	{
		if(P2GameInfoSingle(Level.Game).xManager.bOverwriteWeaponProperties)
			AmbientGlow = P2GameInfoSingle(Level.Game).xManager.iWeaponBrightness;
		else
			AmbientGlow = default.AmbientGlow;
	}
	else
	{
		FinalGlow = AmbientGlow + FlashGlow;
		if( FinalGlow > 250 )
			FinalGlow = 250;

		AmbientGlow = FinalGlow;
	}
}

//=====================================================================================
// Added by Man Chrzan: xPatch
// Setup xPatch Settings & Reticle Settings
//=====================================================================================
event PostLoadGame()
{
	Super.PostLoadGame();
	
	xSetupSettings();
	GetReticleSettings();
}

simulated function xSetupSettings(optional bool bRestoreDefaults)
{
	//local P2Player OurPlayer;
	local xPatchManager xManager;
	local bool xDoDispOverw;
	local float fCheck;
	
	//OurPlayer = P2Player(Pawn(Owner).Controller);
	xManager = P2GameInfoSingle(Level.Game).xManager;
	
	if(xManager == None)
		return;
		
	SetupAltMuzzleFlash(xManager.iMFEffect);

	if(xManager.bOverwriteWeaponProperties)		//if(class'xPatchManager'.static.GetBool(OurPlayer, "bOverwriteWeaponProperties"))
	{
		// Check if the settings are now different than 
		// current properties and overwrite if needed.
		fCheck = xManager.fWeaponBob; 			//class'xPatchManager'.static.GetFloat(OurPlayer, "fWeaponBob");
		if(fCheck != BobDamping)
			BobDamping = fCheck;
		
		fCheck = xManager.iWeaponBrightness;	//class'xPatchManager'.static.GetFloat(OurPlayer, "iWeaponBrightness");
		if(fCheck != AmbientGlow)
			AmbientGlow = fCheck;
		
		fCheck = xManager.fWeaponFOV;	  		//class'xPatchManager'.static.GetFloat(OurPlayer, "fWeaponFOV");
		if(fCheck != xDisplayFOV) {
			xDisplayFOV = fCheck;
			xDoDispOverw = True;
		}
		fCheck = xManager.fWeaponXoffset; 		//class'xPatchManager'.static.GetFloat(OurPlayer, "fWeaponXoffset");	
		if(fCheck != xOffsetX) {
			xOffsetX = fCheck;
			xDoDispOverw = True;
		}
		fCheck = xManager.fWeaponYoffset; 		//class'xPatchManager'.static.GetFloat(OurPlayer, "fWeaponYoffset");	
		if(fCheck != xOffsetY) {
			xOffsetY = fCheck;
			xDoDispOverw = True;
		}	
		fCheck = xManager.fWeaponZoffset; 		//class'xPatchManager'.static.GetFloat(OurPlayer, "fWeaponZoffset");
		if(fCheck != xOffsetZ) {
			xOffsetZ = fCheck;
			xDoDispOverw = True;
		}
		
		if(xDoDispOverw)
			xDisplayOverwrite = True;
			
		//P2Player(Instigator.Controller).ClientMessage("xPatch: Overwrited weapon properties");
	}
	
	// Restore default properties
	if(bRestoreDefaults)
	{
		//xDisplayOverwrite = False;
		BobDamping = default.BobDamping;
		AmbientGlow = default.AmbientGlow;
		xDisplayFOV = 0;
		xOffsetX = 0;
		xOffsetY = 0;
		xOffsetZ = 0;
	}
}

///////////////////////////////////////////////////////////////////////////////
// This is called whenever xPatch settings are updated
///////////////////////////////////////////////////////////////////////////////
static simulated function ViewmodelSettingsUpdated(P2Player player, bool Defaults)
{
	local Inventory inv;

	log(Player$" xPatch: Weapon settings updated ");
	if (player != None && player.Pawn != None)
	{
		// Tell all player's weapons to update their reticles
		inv = player.Pawn.Inventory;
		while (inv != None)
			{
			if (P2Weapon(inv) != None)
				P2Weapon(inv).xSetupSettings(Defaults);
			inv = inv.Inventory;
			}
	}
}

//=====================================================================================
// Added by Man Chrzan: xPatch
// Spawn some actual shells
//=====================================================================================
function SetupShell()
{
	if (P2GameInfoSingle(Level.Game).xManager != None
		&& P2GameInfoSingle(Level.Game).xManager.bShellCases 
		&& Level.Game.bIsSinglePlayer)
	{
		if (SM == None && ShellClass != None)
		{
			SM = spawn(class'P2ShellMaker', Instigator);
			AttachToBone(SM, ShellBoneName);
			SM.SetRelativeLocation(ShellRelativeLocation);
		}
	}
	
	if(bCheckShell)
		CheckShell();
}
function CheckShell()
{
	local int i;
	
	// Hide old in-animation shell
	if (P2GameInfoSingle(Level.Game).xManager != None
		&& P2GameInfoSingle(Level.Game).xManager.bShellCases 
		&& Level.Game.bIsSinglePlayer)
	{
		for(i=0; i<Skins.Length; i++)
		{
			if(Skins[i] == ShellTex)
				Skins[i] = InvShellTex;
		}
	}
	else
	{
		for(i=0; i<Skins.Length; i++)
		{
			if(default.Skins[i] == ShellTex && Skins[i] == InvShellTex)
				Skins[i] = default.Skins[i];
		}
	}
}
function Notify_SpawnShell()
{
	local vector Start, X,Y,Z;

	if(ShellClass == None)
		return;
	
	if (Level.Game.bIsSinglePlayer
		&& P2GameInfoSingle(Level.Game).xManager != None
		&& P2GameInfoSingle(Level.Game).xManager.bShellCases)
	{
		GetAxes(Instigator.GetViewRotation(),X,Y,Z);
		if (IsFirstPersonView())
//			Start = GetBoneCoords(ShellBoneName).Origin;//+vect(-43,0,0) >> Rotation;
			Start = SM.Location;
		else
			Start = ThirdPersonActor.Location;
		AdjustedAim = Instigator.AdjustAim(AmmoType, Start, 2*AimError);
		shell = spawn(ShellClass,Instigator,,Start, AdjustedAim);

		if (shell != None)
		{
			shell.SetDrawScale(ShellScale);
			shell.AmbientGlow = AmbientGlow;
			shell.Eject(((fRand() * 0.2 + 0.2) * Y * ShellSpeedY) + ((fRand() * 0.3 + 0.3) * Z * ShellSpeedZ) + Instigator.Velocity);
		}
	}
}

//=====================================================================================
// Added by Man Chrzan: xPatch
// Setup Oldskool Hands
//=====================================================================================

///////////////////////////////////////////////////////////////////////////////
// Swap meshes and animations appropriately 
///////////////////////////////////////////////////////////////////////////////
function SwapHandsOld()
{
	if(!bOldHands)
	{
		// Swap mesh
		LinkMesh( OldMesh, true);
		bOldHands = True;
		SwapHandsSkin();
	}
}
function SwapHandsNew()
{
	if(bOldHands || Mesh == OldMesh)
	{
		// Swap mesh
		LinkMesh( Default.Mesh, true);
		bOldHands = False;
		SwapHandsSkin();
	}
}

///////////////////////////////////////////////////////////////////////////////
// Swaps old hands skin (after the model is switched)
///////////////////////////////////////////////////////////////////////////////
function SwapHandsSkin()
{
	local Texture DefDudeHands, DefOldDudeHands, CurrentDudeHands;
	local int i;
	
	DefDudeHands = Class'P2Player'.default.DefaultHandsTexture;
	DefOldDudeHands = Class'P2Player'.default.DefaultClassicHandsTexture;
	if(P2Player(Instigator.Controller) != None)
		CurrentDudeHands = P2Player(Instigator.Controller).GetCurrentClothesHandsTexture();
	
	// Swap dude's hands skin if needed
	for(i=0; i<Skins.Length; i++)
	{
		if(Default.Skins[i] == DefDudeHands)
		{
			// Wearing some unusual clothes (Gimp, Cop, etc)
			if(CurrentDudeHands != None)
			{
				if(bOldHands)
					ChangeOldHandTexture(CurrentDudeHands, DefDudeHands, None);
				else
					ChangeHandTexture(CurrentDudeHands, DefDudeHands, None);
			}
			else // Wearing usual clothes
			{
				if(bOldHands)
					Skins[i] = DefOldDudeHands;
				else
					Skins[i] = DefDudeHands;
			}
		}		
	}
}

///////////////////////////////////////////////////////////////////////////////
// Swaps old hands skin (for clothes change)
///////////////////////////////////////////////////////////////////////////////
function ChangeOldHandTexture(Texture NewHandsTexture, Texture DefHandsTexture, Texture NewFootTexture)
{
	local int i, j;
	local P2Player p2p;
	
	p2p = P2Player(Instigator.Controller);
	if(p2p == None)
		return;
	
	for(i=0; i<Skins.Length; i++)
	{
		if(default.Skins[i] == DefHandsTexture)
		{
			for(j=0; j<p2p.ReplaceHandsSkins.Length; j++)
			{
				if(NewHandsTexture == p2p.ReplaceHandsSkins[j].NewSkin)
					Skins[i] = p2p.ReplaceHandsSkins[j].OldSkin;
				else // If we can't find a proper texture to swap to, use the default old dude's hands skin.
					 // Doesn't take a genius to figure out what would happened if we got an new texture on a old model.
					Skins[i] = p2p.DefaultClassicHandsTexture;
			}
		}
	}	
}

///////////////////////////////////////////////////////////////////////////////
// This is false by default for all P2Weapon extensions.
// Individual weapons have it overwritten to properly allow swap.
// Otherwise we would get extending weapons fooked up.
///////////////////////////////////////////////////////////////////////////////
function bool CanSwapHands()
{
	return false;
}
function bool DoSwapHands()
{
	return 	(P2GameInfoSingle(Level.Game).InClassicMode() 
				&& P2GameInfoSingle(Level.Game).xManager.bClassicHands 
				&& CanSwapHands()
				&& OldMesh != None);
}

///////////////////////////////////////////////////////////////////////////////
// DEBUG: Forces current weapon change the weapon model
///////////////////////////////////////////////////////////////////////////////
exec function TOldHands()
{
	if (!P2Player(Instigator.Controller).DebugEnabled())
		return;
	
	if(!bOldHands)
		SwapHandsOld();
	else
		SwapHandsNew();
	
	PlayIdleAnim();
	P2Player(Instigator.Controller).ClientMessage("OldHands: "@bOldHands);
}
exec function ForceBringUp()
{
	BringUp();
}

//=====================================================================================
// Added by Man Chrzan: xPatch
// Actual Reloading Support
//=====================================================================================

// Updated Reloading
state Reloading
{
	simulated function BeginState()
	{
		Super.BeginState();
		
		// Hide crosshair on reload
		if(!bNoHudReticle && bNoHudReticleReload)
			bNoHudReticle = true;
	}

	simulated function AnimEnd(int Channel)
	{
		local int TopUpAmount;

		// if it's actual reloadable weapon we use up ammo for reloading
		if(bReloadableWeapon)
		{
			if(!P2AmmoInv(AmmoType).bInfinite)
			{
				TopUpAmount = Min((Default.ReloadCount - ReloadCount), AmmoType.AmmoAmount);
				ReloadCount += TopUpAmount;
				P2AmmoInv(AmmoType).UseAmmoForShot(TopUpAmount);
			}
			if(Role < ROLE_Authority)
				ClientFinish();
			else
				Finish();	
			CheckAnimating();
		}
		else // otherwise we use the old method
			Super.AnimEnd(Channel);
	}

	simulated function EndState()
	{
		Super.EndState();
		
		// Show crosshair again
		if(bNoHudReticleReload)
			bNoHudReticle = Default.bNoHudReticle;
	}
}

// return percent of full ammo (0 to 1 range)
function float AmmoStatus()
{
	if(bReloadableWeapon)
		return float(AmmoType.AmmoAmount+ReloadCount)/AmmoType.MaxAmmo;
	else
		return float(AmmoType.AmmoAmount)/AmmoType.MaxAmmo;
}

// Same as in AmmoType for normal weapons 
// but different for reloadable
simulated function bool HasAmmoFinished()
{
	if(bReloadableWeapon)
		return HasAmmo();
	else
		return P2AmmoInv(AmmoType).HasAmmoFinished();
}

// Manual reload (we bind it to a key)
exec function Reload()
{
	if (AmmoType.AmmoAmount > 0 
		&& ReloadCount != default.ReloadCount 
		&& ReloadCount != 0)
	{
		//if (FPSGameInfo(Level.Game).bIsSinglePlayer)
			ForceReload(); 
		//else
		//	ServerForceReload();
		
		// Disable reload hint
		bShowReloadHints=false;
	}
}

///////////////////////////////////////////////////////////////////////////////
// DefaultProperties
///////////////////////////////////////////////////////////////////////////////
defaultproperties
{
	DrawScale=1
	//DisplayFOV=+60.0
	DisplayFOV=+70.0 // 60.0
	//PlayerViewOffset=(X=2.0000,Y=0.000000,Z=-2.0000)
	PlayerViewOffset=(X=2.0000,Y=0.000000,Z=-10.0000) // Z= -10.00

	bMakeInfiniteForNPCs=true

	PickUpAmmoCount=0

	TransientSoundRadius=100
    //FireOffset=(X=2.000000,Y=0.00000,Z=-1.00000)
	//FireOffset=(X=2.000000,Y=0.00000,Z=-10.00000) // Z= -1.00
	FireOffset=(X=0,Y=-1,Z=0)
	ShotCountMaxForNotify=1
	AI_BurstCountExtra=0
	AI_BurstCountMin=1
	CombatRating=0.0

	ShakeRollRate=12000
	ShakeOffsetTime=1

	PawnHitMarkerMade=class'PawnShotMarker'

	SelectSound=Sound'WeaponSounds.weapon_select'

	holdstyle=WEAPONHOLDSTYLE_None
	switchstyle=WEAPONHOLDSTYLE_None
	firingstyle=WEAPONHOLDSTYLE_None

	WeaponSpeedIdle	   = 0.5
	WeaponSpeedHolster = 1.0
	WeaponSpeedLoad    = 1.0
	WeaponSpeedReload  = 1.0
	WeaponSpeedShoot1  = 1.0
	WeaponSpeedShoot2  = 1.0
	WeaponFirePitchStart = 0.96
	WeaponFirePitchRand = 0.08

	AmbientGlow = 128
	// Since we don't use dynamic lights, turn these off. It keeps unnecessary variables
	// from getting replicated--saves bandwidth.
//	LightEffect=LE_NonIncidence
//	LightType=LT_Steady

	NoAmmoChangeState="DownWeapon"

	DropWeaponHint1="Press %KEY_ThrowWeapon% to drop your weapon."
	DropWeaponHint2=""
	StandStillHint="Stand still to be cuffed."
	HudHint1=""
	HudHint2=""
	HudHint3=""
	TooMuchAmmoHint="You're already at full ammo."
	TooManyOfTheseHint="You already have one of these."
	bAllowHints=false
	bShowHints=false
	FlashMax=3
	bBumpStartsFight=true
	WeaponsPackageStr = "FP_Weapons."
	bCanThrowMP=true
    bOverrideAutoFOV=false
	ReticleDefaultColor	= (R=255,G=255,B=255,A=90)
	ReticleColor	= (R=255,G=255,B=255,A=90)
	ReticleTexture=Texture'P2Misc.Reticle.Reticle_Crosshair_Cross' //Texture'P2Misc.Reticle.Reticle_Crosshair_Redline'
	ControllerFOV = 0
	bAllowAimAssist=true
	
	// Man Chrzan: xPatch
	MFClass[0]=class'xMuzzleFlashEmitter'
	bShowReloadHints=True		// Needs to be true by default. ALWAYS!
	bAllowReloadHints=False 	// This can be set in various weapons as desired. 
	ReloadHint1="Press %KEY_Reload% to reload manually."
	InvShellTex=Texture'Timb.Misc.invisible_timb'
	ShellScale=1.0
	VeteranModeDropChance=0.35
	
	GroupFullMessage="You can only carry one weapon in group"
	GroupFullMessage2A="You can only carry"
	GroupFullMessage2B="weapons in group"
}
