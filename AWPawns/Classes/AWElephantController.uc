///////////////////////////////////////////////////////////////////////////////
// AWElephantController
// Copyright 2004 RWS, Inc.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////
class AWElephantController extends ElephantController;

///////////////////////////////////////////////////////////////////////////////
// vars
///////////////////////////////////////////////////////////////////////////////
var P2Player DPlayer;		// Dude player in my area. Use it to shake his view as you run around
var AWElephantShake MyShaker;	// Checks to shake view of player while elephant is charging

///////////////////////////////////////////////////////////////////////////////
// consts
///////////////////////////////////////////////////////////////////////////////
const HIT_FRONT_DOT	=	0.9;


///////////////////////////////////////////////////////////////////////////////
// start: set up functions (from spawner and the like)
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Find a closet actor with this tag (should be a pawn) and kick his butt
// If not tag, then start dervishing after the spawn anyways.
///////////////////////////////////////////////////////////////////////////////
function SetToAttackTag(Name AttackTag)
{
	local FPSPawn AttackHim;

	AttackHim = FPSPawn(FindNearestActorByTag(AttackTag));

	// check for some one to attack
	if(AttackHim != None)
	{
		SetAttacker(AttackHim);
		InterestPawn = AttackHim;
		SetEndGoal(InterestPawn, DEFAULT_END_RADIUS);
		GotoStateSave('ChargeAtTarget');
	}
	else
		GotoStateSave('Ramaging');
}

///////////////////////////////////////////////////////////////////////////////
// Find a player and kick his butt
///////////////////////////////////////////////////////////////////////////////
function SetToAttackPlayer(FPSPawn PlayerP)
{
	local FPSPawn keepp;

	// When we get triggered, we attack the player.

	if(PlayerP == None)
		keepp = GetRandomPlayer().MyPawn;
	else
		keepp = PlayerP;

	// check for some one to attack
	if(keepp != None)
	{
		SetAttacker(keepp);
		InterestPawn = keepp;
		SetEndGoal(InterestPawn, DEFAULT_END_RADIUS);
		GotoStateSave('ChargeAtTarget');
	}
	else
		GotoStateSave('Ramaging');
}

///////////////////////////////////////////////////////////////////////////////
// end: set up functions (from spawner and the like)
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Someone might have shouted get down, said hi, or asked for money.. see what to do
// Go to state to see if we care to get down after someone told us to
///////////////////////////////////////////////////////////////////////////////
function RespondToTalker(Pawn Talker, Pawn AttackingShouter, ETalk TalkType, out byte StateChange)
{
	if(Attacker == None)
	{
		if(FRand() <= 0.5)
			GotoStateSave('Rearup');
		else
			GotoStateSave('Trumpet');
		StateChange=1;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Rear up after hit by the sledge
///////////////////////////////////////////////////////////////////////////////
function DoSledgeRearUp()
{
	GotoState('SledgeRearUp');
}

///////////////////////////////////////////////////////////////////////////////
// If you're hit by a sledge, freak out, unless you already are
///////////////////////////////////////////////////////////////////////////////
function NotifyTakeHit(pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	if ((ClassIsChildOf(damageType, class'SledgeDamage')
			|| ClassIsChildOf(damageType, class'MacheteDamage')
			|| ClassIsChildOf(damageType, class'ScytheDamage'))
		&& MyPawn.Health > 0)
		DoSledgeRearUp();
	else
		Super.NotifyTakeHit(InstigatedBy, HitLocation, Damage, DamageType, Momentum);
} 

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Decide what to do next
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state Thinking
{
Begin:
	Sleep(2*FRand());

	// walk to some random place I can see (not through walls)
	if(!PickRandomDest())
		UseNearestPathNode(2048);
	SetNextState('Thinking');
	GotoStateSave('WalkToTarget');
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// ChargeAtTarget
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state ChargeAtTarget
{
	///////////////////////////////////////////////////////////////////////////////
	// Handle bumps with other characters
	///////////////////////////////////////////////////////////////////////////////
	event Bump(actor Other)
	{
		local vector Rot, Diff, dmom;
		local float dot1, dot2;

		if(TreeKActor(Other) != None
			&& !TreeKActor(Other).bFallen)
		{
			// Stop after you knock over a previously standing tree
			if(FRand() < 0.5)
				GotoStateSave('StompArea');
			else
				GotoStateSave('Rearup');
		}
		else
		{
			// See if it's hitting my front
			Rot = vector(Pawn.Rotation);
			dmom = Other.Location - Pawn.Location;
			dmom.z=0;
			dmom = Normal(dmom);
			dot1 = Rot Dot dmom;

			if(dot1 > HIT_FRONT_DOT)
				Super.Bump(Other);
		}
	}
	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function BeginState()
	{
		local P2Player p2p;

		Super.BeginState();

		// Start running sound
		AWElephantPawn(MyPawn).StartRunningSound();
		// Whether or not we're attacking the player, if we don't
		// have a link to him already, find him and link to him. We'll use
		// this to shake the camera as we run around
		if(DPlayer == None)
		{
			foreach DynamicActors(class'P2Player', p2p)
			{
				if(p2p != None)
					DPlayer  = p2p;
			}
		}
		// Make a shaker for this elephant
		if(MyShaker == None && AWElephantPawn(Pawn) != None && AWElephantPawn(Pawn).bScreenShake)
		{
			MyShaker = spawn(class'AWElephantShake', Pawn);
			MyShaker.LinkToElephantAndPlayer(AWElephantPawn(Pawn), DPlayer);
		}
	}

	///////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////
	function EndState()
	{
		Super.EndState();

		// Stop running sound
		AWElephantPawn(MyPawn).StopRunningSound();
		// Stop shaker
		if(MyShaker != None)
		{
			MyShaker.Destroy();
			MyShaker = None;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// SledgeRearup
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
state SledgeRearup extends Rearup
{
	ignores DoSledgeRearUp;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

defaultproperties
{
}
